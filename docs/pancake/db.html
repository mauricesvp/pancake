<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pancake.db API documentation</title>
<meta name="description" content="Module containing the Pancake Database." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pancake.db</code></h1>
</header>
<section id="section-intro">
<p>Module containing the Pancake Database.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Module containing the Pancake Database. &#34;&#34;&#34;
from typing import Type, Union

import numpy as np
import sqlite3
import time
import threading

from torch.jit import Error

from .detector import Detector
from .detector.backends import Backend
from .tracker import BaseTracker

from .utils.common import fix_path
from .utils.parser import get_config

from .logger import setup_logger


l = setup_logger(__name__)


class DataBase:
    def __init__(self, db_name: str, relations: dict, inserts: dict, *args, **kwargs):
        &#34;&#34;&#34;Encapsulates the Pancake database

        Args:
            db_name (str): Database filename
            relations (dict): Contains create queries for custom relationships
            inserts (dict): Holds corresponding insert queries

        Raises:
            ConnectionError: Raised when sqlite3 can&#39;t connect to the database
        &#34;&#34;&#34;
        try:
            self.con = sqlite3.connect(db_name, check_same_thread=False)
            self.relations = relations
            self.inserts = inserts
        except Exception as e:
            l.error(
                f&#34;Error while connecting to the DB: {e} \n&#34;
                &#34;Proceed tracking without database logging&#34;
            )
            raise ConnectionError

        assert (
            len(self.relations.items()) &gt; 0
        ), &#34;No relationships found to build database from!&#34;

        self.create_tables()
        self.initial_insert(DBT=kwargs)  # Detector, Backend, Tracker

    def create_tables(self) -&gt; None:
        &#34;&#34;&#34; Creates tables for provided relationships in self.relations.

        Raises:
            ConnectionError: Raised when an error occurs while trying to create \
                                table.
        &#34;&#34;&#34;
        cursor = self.con.cursor()

        for rel_name, query in self.relations.items():
            if type(query) is str:
                try:
                    cursor.execute(query)
                except Exception as e:
                    l.error(
                        f&#34;Error occured while executing query for {rel_name}: {e} \n&#34;
                        &#34;Proceed tracking without database logging&#34;
                    )
                    raise ConnectionError

    def initial_insert(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;Method to log the static application setup.&#34;&#34;&#34;
        cursor = self.con.cursor()

        if &#34;DETECTOR&#34; in kwargs[&#34;DBT&#34;]:
            detector: Type[Detector] = kwargs[&#34;DBT&#34;][&#34;DETECTOR&#34;]

            # DETECTOR insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                cursor.execute(
                    self.inserts[&#34;DETECTOR&#34;],
                    (
                        1,
                        detector.__class__.__name__,
                        detector.weights if hasattr(detector, &#34;weights&#34;) else &#34;NULL&#34;,
                    ),
                )
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for DETECTOR&#34;)

            # CLASSES insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                for id, label in enumerate(detector.model.names):
                    cursor.execute(self.inserts[&#34;CLASSES&#34;], (id + 1, label))
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for CLASSES&#34;)

        if &#34;BACKEND&#34; in kwargs[&#34;DBT&#34;]:
            backend: Type[Backend] = kwargs[&#34;DBT&#34;][&#34;BACKEND&#34;]

            # BACKEND insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                cursor.execute(
                    self.inserts[&#34;BACKEND&#34;],
                    (1, backend.__class__.__name__),
                )
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for BACKEND&#34;)

        if &#34;TRACKER&#34; in kwargs[&#34;DBT&#34;]:
            tracker: Type[BaseTracker] = kwargs[&#34;DBT&#34;][&#34;TRACKER&#34;]

            # TRACKER insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                cursor.execute(
                    self.inserts[&#34;TRACKER&#34;],
                    (1, tracker.__class__.__name__),
                )
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for TRACKER&#34;)

        self.con.commit()

    def insert_tracks(self, *args, **kwargs):
        &#34;&#34;&#34;Calls a thread to execute the query with provided arguments.&#34;&#34;&#34;
        t = threading.Thread(target=self.run_insert_tracks, args=args, kwargs=kwargs)
        t.start()

    def run_insert_tracks(self, tracks: np.ndarray, timestamp: float):
        &#34;&#34;&#34;Executes query with provided tracks matrix.

        If no timestamp is provided, we take the current timestamp.
        Reorders the matrix to match the database relation in order to be
        inserted via .executemany().
        Skips the query when an error occurs.

        Args:
            tracks (np.ndarray): Tracks on [x1, y1, x2, y2, centre x, centre y, id, cls]
            timestamp (float): A timestamp of format time.time() timestamp
        &#34;&#34;&#34;
        if len(tracks) &lt; 1:
            l.debug(&#34;Tracks are empty, skipping insert.&#34;)
            return

        if not timestamp:
            timestamp = time.time()
        cursor = self.con.cursor()

        # append timestamp to 0th column, 0 if timestamp is None, 69 is a dummy entry for cls
        insertable = np.c_[
            np.full((tracks.shape[0]), timestamp if timestamp else 0),
            tracks,
            # np.full((tracks.shape[0]), 69),
        ]

        #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
        # order: [id, ts, cx, cy, x1, y1, x2, y2, cls] (for &#34;extended_db.yaml&#34;)
        new_order = [7, 0, 5, 6, 1, 2, 3, 4, 8]
        insertable = insertable[:, new_order]

        try:
            cursor.executemany(self.inserts[&#34;TRACKS&#34;], insertable)
            self.con.commit()
        except Exception as e:
            l.error(f&#34;{e} - bad query..&#34;)


def setup_database(
    cfg: dict,
    detector: Type[Detector] = None,
    backend: Type[Backend] = None,
    tracker: Type[BaseTracker] = None,
) -&gt; Union[DataBase, None]:
    &#34;&#34;&#34;Helper function to set up the Pancake database.

    Description:
        The different objects are parsed in order to log the static application
        setup. They are inserted during the initialization procedure of the database.

    Args:
        cfg (dict): Dictionary containing configurations.
        detector (Type[Detector], optional): A detector instance. Defaults to None.
        backend (Type[Backend], optional): A backend instance. Defaults to None.
        tracker (Type[BaseTracker], optional): A tracker instance. Defaults to None.

    Returns:
        Union[DataBase, None]: An instance of the pancake database if the flag was set,
                                None otherwise.
    &#34;&#34;&#34;
    db_schema = get_config(config_file=fix_path(cfg.SCHEME_PATH)).PANCAKE_DB

    relations = db_schema.RELATIONS
    inserts = db_schema.INSERTS

    return (
        DataBase(
            cfg.FILENAME,
            relations,
            inserts,
            DETECTOR=detector,
            BACKEND=backend,
            TRACKER=tracker,
        )
        if cfg.STORE
        else None
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pancake.db.setup_database"><code class="name flex">
<span>def <span class="ident">setup_database</span></span>(<span>cfg: dict, detector: Type[<a title="pancake.detector.detector.Detector" href="detector/detector.html#pancake.detector.detector.Detector">Detector</a>] = None, backend: Type[<a title="pancake.detector.backends.backend.Backend" href="detector/backends/backend.html#pancake.detector.backends.backend.Backend">Backend</a>] = None, tracker: Type[<a title="pancake.tracker.tracker.BaseTracker" href="tracker/tracker.html#pancake.tracker.tracker.BaseTracker">BaseTracker</a>] = None) ‑> Union[<a title="pancake.db.DataBase" href="#pancake.db.DataBase">DataBase</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to set up the Pancake database.</p>
<h2 id="description">Description</h2>
<p>The different objects are parsed in order to log the static application
setup. They are inserted during the initialization procedure of the database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing configurations.</dd>
<dt><strong><code>detector</code></strong> :&ensp;<code>Type[Detector]</code>, optional</dt>
<dd>A detector instance. Defaults to None.</dd>
<dt><strong><code>backend</code></strong> :&ensp;<code>Type[Backend]</code>, optional</dt>
<dd>A backend instance. Defaults to None.</dd>
<dt><strong><code>tracker</code></strong> :&ensp;<code>Type[BaseTracker]</code>, optional</dt>
<dd>A tracker instance. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="pancake.db.DataBase" href="#pancake.db.DataBase">DataBase</a>, None]</code></dt>
<dd>An instance of the pancake database if the flag was set,
None otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_database(
    cfg: dict,
    detector: Type[Detector] = None,
    backend: Type[Backend] = None,
    tracker: Type[BaseTracker] = None,
) -&gt; Union[DataBase, None]:
    &#34;&#34;&#34;Helper function to set up the Pancake database.

    Description:
        The different objects are parsed in order to log the static application
        setup. They are inserted during the initialization procedure of the database.

    Args:
        cfg (dict): Dictionary containing configurations.
        detector (Type[Detector], optional): A detector instance. Defaults to None.
        backend (Type[Backend], optional): A backend instance. Defaults to None.
        tracker (Type[BaseTracker], optional): A tracker instance. Defaults to None.

    Returns:
        Union[DataBase, None]: An instance of the pancake database if the flag was set,
                                None otherwise.
    &#34;&#34;&#34;
    db_schema = get_config(config_file=fix_path(cfg.SCHEME_PATH)).PANCAKE_DB

    relations = db_schema.RELATIONS
    inserts = db_schema.INSERTS

    return (
        DataBase(
            cfg.FILENAME,
            relations,
            inserts,
            DETECTOR=detector,
            BACKEND=backend,
            TRACKER=tracker,
        )
        if cfg.STORE
        else None
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pancake.db.DataBase"><code class="flex name class">
<span>class <span class="ident">DataBase</span></span>
<span>(</span><span>db_name: str, relations: dict, inserts: dict, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Encapsulates the Pancake database</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Database filename</dd>
<dt><strong><code>relations</code></strong> :&ensp;<code>dict</code></dt>
<dd>Contains create queries for custom relationships</dd>
<dt><strong><code>inserts</code></strong> :&ensp;<code>dict</code></dt>
<dd>Holds corresponding insert queries</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionError</code></dt>
<dd>Raised when sqlite3 can't connect to the database</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataBase:
    def __init__(self, db_name: str, relations: dict, inserts: dict, *args, **kwargs):
        &#34;&#34;&#34;Encapsulates the Pancake database

        Args:
            db_name (str): Database filename
            relations (dict): Contains create queries for custom relationships
            inserts (dict): Holds corresponding insert queries

        Raises:
            ConnectionError: Raised when sqlite3 can&#39;t connect to the database
        &#34;&#34;&#34;
        try:
            self.con = sqlite3.connect(db_name, check_same_thread=False)
            self.relations = relations
            self.inserts = inserts
        except Exception as e:
            l.error(
                f&#34;Error while connecting to the DB: {e} \n&#34;
                &#34;Proceed tracking without database logging&#34;
            )
            raise ConnectionError

        assert (
            len(self.relations.items()) &gt; 0
        ), &#34;No relationships found to build database from!&#34;

        self.create_tables()
        self.initial_insert(DBT=kwargs)  # Detector, Backend, Tracker

    def create_tables(self) -&gt; None:
        &#34;&#34;&#34; Creates tables for provided relationships in self.relations.

        Raises:
            ConnectionError: Raised when an error occurs while trying to create \
                                table.
        &#34;&#34;&#34;
        cursor = self.con.cursor()

        for rel_name, query in self.relations.items():
            if type(query) is str:
                try:
                    cursor.execute(query)
                except Exception as e:
                    l.error(
                        f&#34;Error occured while executing query for {rel_name}: {e} \n&#34;
                        &#34;Proceed tracking without database logging&#34;
                    )
                    raise ConnectionError

    def initial_insert(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;Method to log the static application setup.&#34;&#34;&#34;
        cursor = self.con.cursor()

        if &#34;DETECTOR&#34; in kwargs[&#34;DBT&#34;]:
            detector: Type[Detector] = kwargs[&#34;DBT&#34;][&#34;DETECTOR&#34;]

            # DETECTOR insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                cursor.execute(
                    self.inserts[&#34;DETECTOR&#34;],
                    (
                        1,
                        detector.__class__.__name__,
                        detector.weights if hasattr(detector, &#34;weights&#34;) else &#34;NULL&#34;,
                    ),
                )
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for DETECTOR&#34;)

            # CLASSES insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                for id, label in enumerate(detector.model.names):
                    cursor.execute(self.inserts[&#34;CLASSES&#34;], (id + 1, label))
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for CLASSES&#34;)

        if &#34;BACKEND&#34; in kwargs[&#34;DBT&#34;]:
            backend: Type[Backend] = kwargs[&#34;DBT&#34;][&#34;BACKEND&#34;]

            # BACKEND insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                cursor.execute(
                    self.inserts[&#34;BACKEND&#34;],
                    (1, backend.__class__.__name__),
                )
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for BACKEND&#34;)

        if &#34;TRACKER&#34; in kwargs[&#34;DBT&#34;]:
            tracker: Type[BaseTracker] = kwargs[&#34;DBT&#34;][&#34;TRACKER&#34;]

            # TRACKER insert
            try:
                #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
                cursor.execute(
                    self.inserts[&#34;TRACKER&#34;],
                    (1, tracker.__class__.__name__),
                )
            except Exception as e:
                l.info(f&#34;{e}&#34;)
                l.info(&#34;Skip initial query for TRACKER&#34;)

        self.con.commit()

    def insert_tracks(self, *args, **kwargs):
        &#34;&#34;&#34;Calls a thread to execute the query with provided arguments.&#34;&#34;&#34;
        t = threading.Thread(target=self.run_insert_tracks, args=args, kwargs=kwargs)
        t.start()

    def run_insert_tracks(self, tracks: np.ndarray, timestamp: float):
        &#34;&#34;&#34;Executes query with provided tracks matrix.

        If no timestamp is provided, we take the current timestamp.
        Reorders the matrix to match the database relation in order to be
        inserted via .executemany().
        Skips the query when an error occurs.

        Args:
            tracks (np.ndarray): Tracks on [x1, y1, x2, y2, centre x, centre y, id, cls]
            timestamp (float): A timestamp of format time.time() timestamp
        &#34;&#34;&#34;
        if len(tracks) &lt; 1:
            l.debug(&#34;Tracks are empty, skipping insert.&#34;)
            return

        if not timestamp:
            timestamp = time.time()
        cursor = self.con.cursor()

        # append timestamp to 0th column, 0 if timestamp is None, 69 is a dummy entry for cls
        insertable = np.c_[
            np.full((tracks.shape[0]), timestamp if timestamp else 0),
            tracks,
            # np.full((tracks.shape[0]), 69),
        ]

        #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
        # order: [id, ts, cx, cy, x1, y1, x2, y2, cls] (for &#34;extended_db.yaml&#34;)
        new_order = [7, 0, 5, 6, 1, 2, 3, 4, 8]
        insertable = insertable[:, new_order]

        try:
            cursor.executemany(self.inserts[&#34;TRACKS&#34;], insertable)
            self.con.commit()
        except Exception as e:
            l.error(f&#34;{e} - bad query..&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pancake.db.DataBase.create_tables"><code class="name flex">
<span>def <span class="ident">create_tables</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Creates tables for provided relationships in self.relations.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionError</code></dt>
<dd>Raised when an error occurs while trying to create
table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tables(self) -&gt; None:
    &#34;&#34;&#34; Creates tables for provided relationships in self.relations.

    Raises:
        ConnectionError: Raised when an error occurs while trying to create \
                            table.
    &#34;&#34;&#34;
    cursor = self.con.cursor()

    for rel_name, query in self.relations.items():
        if type(query) is str:
            try:
                cursor.execute(query)
            except Exception as e:
                l.error(
                    f&#34;Error occured while executing query for {rel_name}: {e} \n&#34;
                    &#34;Proceed tracking without database logging&#34;
                )
                raise ConnectionError</code></pre>
</details>
</dd>
<dt id="pancake.db.DataBase.initial_insert"><code class="name flex">
<span>def <span class="ident">initial_insert</span></span>(<span>self, *args, **kwargs) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Method to log the static application setup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initial_insert(self, *args, **kwargs) -&gt; None:
    &#34;&#34;&#34;Method to log the static application setup.&#34;&#34;&#34;
    cursor = self.con.cursor()

    if &#34;DETECTOR&#34; in kwargs[&#34;DBT&#34;]:
        detector: Type[Detector] = kwargs[&#34;DBT&#34;][&#34;DETECTOR&#34;]

        # DETECTOR insert
        try:
            #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
            cursor.execute(
                self.inserts[&#34;DETECTOR&#34;],
                (
                    1,
                    detector.__class__.__name__,
                    detector.weights if hasattr(detector, &#34;weights&#34;) else &#34;NULL&#34;,
                ),
            )
        except Exception as e:
            l.info(f&#34;{e}&#34;)
            l.info(&#34;Skip initial query for DETECTOR&#34;)

        # CLASSES insert
        try:
            #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
            for id, label in enumerate(detector.model.names):
                cursor.execute(self.inserts[&#34;CLASSES&#34;], (id + 1, label))
        except Exception as e:
            l.info(f&#34;{e}&#34;)
            l.info(&#34;Skip initial query for CLASSES&#34;)

    if &#34;BACKEND&#34; in kwargs[&#34;DBT&#34;]:
        backend: Type[Backend] = kwargs[&#34;DBT&#34;][&#34;BACKEND&#34;]

        # BACKEND insert
        try:
            #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
            cursor.execute(
                self.inserts[&#34;BACKEND&#34;],
                (1, backend.__class__.__name__),
            )
        except Exception as e:
            l.info(f&#34;{e}&#34;)
            l.info(&#34;Skip initial query for BACKEND&#34;)

    if &#34;TRACKER&#34; in kwargs[&#34;DBT&#34;]:
        tracker: Type[BaseTracker] = kwargs[&#34;DBT&#34;][&#34;TRACKER&#34;]

        # TRACKER insert
        try:
            #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
            cursor.execute(
                self.inserts[&#34;TRACKER&#34;],
                (1, tracker.__class__.__name__),
            )
        except Exception as e:
            l.info(f&#34;{e}&#34;)
            l.info(&#34;Skip initial query for TRACKER&#34;)

    self.con.commit()</code></pre>
</details>
</dd>
<dt id="pancake.db.DataBase.insert_tracks"><code class="name flex">
<span>def <span class="ident">insert_tracks</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls a thread to execute the query with provided arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_tracks(self, *args, **kwargs):
    &#34;&#34;&#34;Calls a thread to execute the query with provided arguments.&#34;&#34;&#34;
    t = threading.Thread(target=self.run_insert_tracks, args=args, kwargs=kwargs)
    t.start()</code></pre>
</details>
</dd>
<dt id="pancake.db.DataBase.run_insert_tracks"><code class="name flex">
<span>def <span class="ident">run_insert_tracks</span></span>(<span>self, tracks: numpy.ndarray, timestamp: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes query with provided tracks matrix.</p>
<p>If no timestamp is provided, we take the current timestamp.
Reorders the matrix to match the database relation in order to be
inserted via .executemany().
Skips the query when an error occurs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tracks</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Tracks on [x1, y1, x2, y2, centre x, centre y, id, cls]</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>float</code></dt>
<dd>A timestamp of format time.time() timestamp</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_insert_tracks(self, tracks: np.ndarray, timestamp: float):
    &#34;&#34;&#34;Executes query with provided tracks matrix.

    If no timestamp is provided, we take the current timestamp.
    Reorders the matrix to match the database relation in order to be
    inserted via .executemany().
    Skips the query when an error occurs.

    Args:
        tracks (np.ndarray): Tracks on [x1, y1, x2, y2, centre x, centre y, id, cls]
        timestamp (float): A timestamp of format time.time() timestamp
    &#34;&#34;&#34;
    if len(tracks) &lt; 1:
        l.debug(&#34;Tracks are empty, skipping insert.&#34;)
        return

    if not timestamp:
        timestamp = time.time()
    cursor = self.con.cursor()

    # append timestamp to 0th column, 0 if timestamp is None, 69 is a dummy entry for cls
    insertable = np.c_[
        np.full((tracks.shape[0]), timestamp if timestamp else 0),
        tracks,
        # np.full((tracks.shape[0]), 69),
    ]

    #!! ADAPT TO CUSTOM SCHEMA IF NECESSARY!!
    # order: [id, ts, cx, cy, x1, y1, x2, y2, cls] (for &#34;extended_db.yaml&#34;)
    new_order = [7, 0, 5, 6, 1, 2, 3, 4, 8]
    insertable = insertable[:, new_order]

    try:
        cursor.executemany(self.inserts[&#34;TRACKS&#34;], insertable)
        self.con.commit()
    except Exception as e:
        l.error(f&#34;{e} - bad query..&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pancake" href="index.html">pancake</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pancake.db.setup_database" href="#pancake.db.setup_database">setup_database</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pancake.db.DataBase" href="#pancake.db.DataBase">DataBase</a></code></h4>
<ul class="">
<li><code><a title="pancake.db.DataBase.create_tables" href="#pancake.db.DataBase.create_tables">create_tables</a></code></li>
<li><code><a title="pancake.db.DataBase.initial_insert" href="#pancake.db.DataBase.initial_insert">initial_insert</a></code></li>
<li><code><a title="pancake.db.DataBase.insert_tracks" href="#pancake.db.DataBase.insert_tracks">insert_tracks</a></code></li>
<li><code><a title="pancake.db.DataBase.run_insert_tracks" href="#pancake.db.DataBase.run_insert_tracks">run_insert_tracks</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>