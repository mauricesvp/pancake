<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pancake.tracker.tracker_centroid_old API documentation</title>
<meta name="description" content="Tracker based on Centroid tracking." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pancake.tracker.tracker_centroid_old</code></h1>
</header>
<section id="section-intro">
<p>Tracker based on Centroid tracking.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Tracker based on Centroid tracking.&#34;&#34;&#34;
from .tracker import BaseTracker
from typing import Type, Union

from pancake.logger import setup_logger

from collections import OrderedDict
import numpy as np
import torch
import time

from scipy.spatial import distance as dist
from operator import itemgetter


class CentroidTracker(BaseTracker):
    def __init__(self, cfg: dict, *args, **kwargs) -&gt; None:
        self.l = setup_logger(__name__)  # You can use any name
        self.l.debug(&#34;INIT CENTROID TRACKER - OLD&#34;)
        # initialize the next unique object ID along with two ordered
        # dictionaries used to keep track of mapping a given object
        # ID to its centroid and number of consecutive frames it has
        # been marked as &#34;disappeared&#34;, respectively
        self.nextObjectID = 0
        self.objects = OrderedDict()
        self.disappeared = OrderedDict()
        # More dicts for return types
        self.bbox = OrderedDict()
        self.confidence = OrderedDict()
        # Previous Group Dicts
        self.previousPos = OrderedDict()
        self.continuedMovement = OrderedDict()
        self.lastValidMovement = OrderedDict()
        # store the number of maximum consecutive frames a given
        # object is allowed to be marked as &#34;disappeared&#34; until we
        # need to deregister the object from tracking
        # constants
        self.MAX_DISAPPEARED = cfg.CENTROID.MAX_DISAPPEARED
        self.IS_VIDEO_INPUT = cfg.CENTROID.IS_VIDEO_INPUT
        self.DISTANCE_TOLERANCE = cfg.CENTROID.DISTANCE_TOLERANCE
        self.VERTICAL_TOLERANCE = cfg.CENTROID.VERTICAL_TOLERANCE
        self.IGNORE_REGISTRATION_ZONES = cfg.CENTROID.IGNORE_REGISTRATION_ZONES
        self.LANE_SEPARATOR = cfg.CENTROID.LANE_SEPARATOR
        self.DEREGISTRATION_ZONE = cfg.CENTROID.DEREGISTRATION_ZONE
        self.FRAME_WIDTH = cfg.CENTROID.FRAME_WIDTH
        # Previous Group
        self.previous_timestamp = None
        self.time_between_frames = 1

    def _centroid(self, vertices):
        x_list = [vertex for vertex in vertices[::2]]
        y_list = [vertex for vertex in vertices[1::2]]
        x = int(sum(x_list) // len(x_list))
        y = int(sum(y_list) // len(y_list))
        return x, y

    def _return(self):
        outputs = []
        for id in list(self.objects.keys()):
            outputs.append(
                np.array(
                    [
                        self.bbox[id][0],
                        self.bbox[id][1],
                        self.bbox[id][2],
                        self.bbox[id][3],
                        self.objects[id][0],
                        self.objects[id][1],
                        id,
                    ],
                    dtype=np.int,
                )
            )

        if len(outputs) &gt; 0:
            outputs = np.stack(outputs, axis=0)

        # self.l.debug(outputs)

        return outputs

    def _continueMovement(self, objectID):
        # check if values for the last valid movement is existing (i.e. the object must have been detected at least once in two consecutive frames)
        if self.lastValidMovement[objectID] is not None:
            self.objects[objectID][0] = self.objects[objectID][0] + (
                self.lastValidMovement[objectID][0] * self.time_between_frames
            )
            self.continuedMovement[objectID] = True

    def _isInsideDeregistrationZone(self, centroid):
        if (
            centroid[1] &lt; self.LANE_SEPARATOR and centroid[0] &lt; self.DEREGISTRATION_ZONE
        ) or (
            centroid[1] &gt; self.LANE_SEPARATOR
            and centroid[0] &gt; (self.FRAME_WIDTH - self.DEREGISTRATION_ZONE)
        ):
            return True
        else:
            return False

    def _isNotInsideDeregistrationZone(self, centroid):
        if (
            (
                centroid[1] &lt; self.LANE_SEPARATOR
                and centroid[0] &gt;= self.DEREGISTRATION_ZONE
            )
            or (
                centroid[1] &gt; self.LANE_SEPARATOR
                and centroid[0] &lt;= (self.FRAME_WIDTH - self.DEREGISTRATION_ZONE)
            )
            or self.IGNORE_REGISTRATION_ZONES
        ):
            return True
        else:
            return False

    def _register(self, centroid, bbox, conf):
        # when registering an object we use the next available object
        # ID to store the centroid
        self.objects[self.nextObjectID] = centroid
        self.disappeared[self.nextObjectID] = 0
        # add other information
        self.bbox[self.nextObjectID] = bbox
        self.confidence[self.nextObjectID] = conf
        # Previous group information
        self.previousPos[self.nextObjectID] = centroid
        self.continuedMovement[self.nextObjectID] = False
        self.lastValidMovement[self.nextObjectID] = None
        # increment objectID
        self.nextObjectID += 1

    def _deregister(self, objectID):
        # to deregister an object ID we delete the object ID from
        # all of our respective dictionaries
        del self.objects[objectID]
        del self.disappeared[objectID]
        del self.bbox[objectID]
        del self.confidence[objectID]
        # Previous Group
        del self.previousPos[objectID]
        del self.continuedMovement[objectID]
        del self.lastValidMovement[objectID]

    def update(
        self, det: Type[torch.Tensor], img: Type[np.ndarray]
    ) -&gt; np.ndarray:  # det: list of koordinates x,y , x,y, ...
        # self.l.debug(&#34;UPDATE CENTROID TRACKER&#34;)
        bbox_xyxy, conf, _ = self.transform_detections(det)

        # Previous Group
        # create current timestamp in ms
        frame_timestamp = int(round(time.time() * 1000))

        if self.previous_timestamp is not None and not self.IS_VIDEO_INPUT:
            self.time_between_frames = frame_timestamp - self.previous_timestamp

        # check to see if the list of input bounding box rectangles
        # is empty
        if len(bbox_xyxy) == 0:
            # loop over any existing tracked objects and mark them
            # as disappeared
            for objectID in list(self.disappeared.keys()):
                self.disappeared[objectID] += 1
                # Previous Group
                self.continuedMovement[objectID] = False
                self._continueMovement(objectID)
                self.previousPos[objectID] = None
                # if we have reached a maximum number of consecutive
                # frames where a given object has been marked as
                # missing, deregister it
                # Or if the object is inside the deregistration zone
                if self.disappeared[
                    objectID
                ] &gt; self.MAX_DISAPPEARED or self._isInsideDeregistrationZone(
                    self.objects[objectID]
                ):
                    self._deregister(objectID)
            # return early as there are no centroids or tracking info
            # to update
            self.previous_timestamp = frame_timestamp
            return self._return()

        # initialize an array of input centroids for the current frame
        inputCentroids = np.zeros((len(bbox_xyxy), 2), dtype=&#34;int&#34;)
        inputBBOX = np.zeros((len(bbox_xyxy), 4), dtype=&#34;int&#34;)
        inputConfidence = np.zeros((len(bbox_xyxy), 1), dtype=&#34;float&#34;)
        # loop over the bounding box rectangles
        for (i, bb) in enumerate(bbox_xyxy):
            # use the bounding box coordinates to derive the centroid
            inputCentroids[i] = self._centroid(bb)
            inputBBOX[i] = bb
            inputConfidence[i] = conf[i]

        # print(&#34;INPUTS:&#34;)
        # print(inputCentroids, inputBBOX, inputConfidence)

        # if we are currently not tracking any objects take the input
        # centroids and register each of them
        if len(self.objects) == 0:
            for i in range(len(inputCentroids)):
                # only register when not in deregistration zone
                if self._isNotInsideDeregistrationZone(inputCentroids[i]):
                    self._register(inputCentroids[i], inputBBOX[i], inputConfidence[i])

        # otherwise, are are currently tracking objects so we need to
        # try to match the input centroids to existing object
        # centroids
        else:
            # grab the set of object IDs and corresponding centroids
            objectIDs = list(self.objects.keys())
            objectCentroids = list(self.objects.values())
            # compute the distance between each pair of object
            # centroids and input centroids, respectively -- our
            # goal will be to match an input centroid to an existing
            # object centroid
            D = dist.cdist(np.array(objectCentroids), inputCentroids)
            # Previous Group
            # create sorted list of tuples of indexes and value in ascending order
            D_sorted = sorted(np.ndenumerate(D), key=itemgetter(1))
            # in order to determine if we need to update, register,
            # or deregister an object we need to keep track of which
            # of the rows and column indexes we have already examined
            usedRows = set()
            usedCols = set()

            # loop through pairs of object, inputCentroid, and distance
            for line in D_sorted:
                row = line[0][0]
                col = line[0][1]
                distance = line[1]
                # if we have already examined either the row or
                # column value before, ignore it
                # val
                if row in usedRows or col in usedCols:
                    continue
                # otherwise, grab the object ID for the current row,
                # set its new centroid, and reset the disappeared
                # counter
                # But only if inside a maximum distance
                if (distance &lt; self.DISTANCE_TOLERANCE) and (
                    abs(self.objects[objectIDs[row]][1] - inputCentroids[col][1])
                    &lt; self.VERTICAL_TOLERANCE
                ):
                    objectID = objectIDs[row]
                    self.objects[objectID] = inputCentroids[col]
                    self.bbox[objectID] = inputBBOX[col]
                    self.confidence[objectID] = inputConfidence[col]
                    self.disappeared[objectID] = 0
                    # Previous Group
                    self.continuedMovement[objectID] = False

                    # Previous Group
                    # save the movement between the last two frames (only, if it is &#34;forward&#34;)
                    if self.previousPos[objectID] is not None:
                        if (
                            self.objects[objectID][1] &lt; self.LANE_SEPARATOR
                            and (
                                self.objects[objectID][0]
                                - self.previousPos[objectID][0]
                            )
                            &lt; 0
                        ) or (
                            self.objects[objectID][1] &gt; self.LANE_SEPARATOR
                            and (
                                self.objects[objectID][0]
                                - self.previousPos[objectID][0]
                            )
                            &gt; 0
                        ):

                            self.lastValidMovement[objectID] = (
                                self.objects[objectID] - self.previousPos[objectID]
                            ) / self.time_between_frames
                        self.previousPos[objectID] = self.objects[objectID]

                    # indicate that we have examined each of the row and
                    # column indexes, respectively
                    usedRows.add(row)
                    usedCols.add(col)

            # compute both the row and column index we have NOT yet
            # examined
            unusedRows = set(range(0, D.shape[0])).difference(usedRows)
            unusedCols = set(range(0, D.shape[1])).difference(usedCols)

            # in the event that the number of object centroids is
            # equal or greater than the number of input centroids
            # we need to check and see if some of these objects have
            # potentially disappeared
            if D.shape[0] &gt;= D.shape[1]:
                # loop over the unused row indexes
                for row in unusedRows:
                    # grab the object ID for the corresponding row
                    # index and increment the disappeared counter
                    objectID = objectIDs[row]
                    self.disappeared[objectID] += 1
                    # Previous Group
                    self.continuedMovement[objectID] = False
                    self._continueMovement(objectID)
                    self.previousPos[objectID] = None
                    # check to see if the number of consecutive
                    # frames the object has been marked &#34;disappeared&#34;
                    # for warrants deregistering the object
                    # Or if object is inside deregistration zone
                    if self.disappeared[
                        objectID
                    ] &gt; self.MAX_DISAPPEARED or self._isInsideDeregistrationZone(
                        objectCentroids[row]
                    ):
                        self._deregister(objectID)

            # otherwise, if the number of input centroids is greater
            # than the number of existing object centroids we need to
            # register each new input centroid as a trackable object
            else:
                for col in unusedCols:
                    if self._isNotInsideDeregistrationZone(inputCentroids[col]):
                        self._register(
                            inputCentroids[col], inputBBOX[col], inputConfidence[col]
                        )

        # return the set of trackable objects
        self.previous_timestamp = frame_timestamp
        return self._return()

    @staticmethod
    def transform_detections(det: Type[torch.Tensor]):
        &#34;&#34;&#34;
        Transform detection vector to numpy

        :param det (torch.Tensor): prediction tensor

        :return xyxy (np.ndarray (,4)): x1, y1, x2, y2
                conf (np.ndarray (,1)): class confidences
                cls  (np,ndarray (,1)): class indeces
        &#34;&#34;&#34;
        t_det = det.cpu().detach().numpy()
        return t_det[:, :4], t_det[..., 4], t_det[..., 5]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pancake.tracker.tracker_centroid_old.CentroidTracker"><code class="flex name class">
<span>class <span class="ident">CentroidTracker</span></span>
<span>(</span><span>cfg: dict, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CentroidTracker(BaseTracker):
    def __init__(self, cfg: dict, *args, **kwargs) -&gt; None:
        self.l = setup_logger(__name__)  # You can use any name
        self.l.debug(&#34;INIT CENTROID TRACKER - OLD&#34;)
        # initialize the next unique object ID along with two ordered
        # dictionaries used to keep track of mapping a given object
        # ID to its centroid and number of consecutive frames it has
        # been marked as &#34;disappeared&#34;, respectively
        self.nextObjectID = 0
        self.objects = OrderedDict()
        self.disappeared = OrderedDict()
        # More dicts for return types
        self.bbox = OrderedDict()
        self.confidence = OrderedDict()
        # Previous Group Dicts
        self.previousPos = OrderedDict()
        self.continuedMovement = OrderedDict()
        self.lastValidMovement = OrderedDict()
        # store the number of maximum consecutive frames a given
        # object is allowed to be marked as &#34;disappeared&#34; until we
        # need to deregister the object from tracking
        # constants
        self.MAX_DISAPPEARED = cfg.CENTROID.MAX_DISAPPEARED
        self.IS_VIDEO_INPUT = cfg.CENTROID.IS_VIDEO_INPUT
        self.DISTANCE_TOLERANCE = cfg.CENTROID.DISTANCE_TOLERANCE
        self.VERTICAL_TOLERANCE = cfg.CENTROID.VERTICAL_TOLERANCE
        self.IGNORE_REGISTRATION_ZONES = cfg.CENTROID.IGNORE_REGISTRATION_ZONES
        self.LANE_SEPARATOR = cfg.CENTROID.LANE_SEPARATOR
        self.DEREGISTRATION_ZONE = cfg.CENTROID.DEREGISTRATION_ZONE
        self.FRAME_WIDTH = cfg.CENTROID.FRAME_WIDTH
        # Previous Group
        self.previous_timestamp = None
        self.time_between_frames = 1

    def _centroid(self, vertices):
        x_list = [vertex for vertex in vertices[::2]]
        y_list = [vertex for vertex in vertices[1::2]]
        x = int(sum(x_list) // len(x_list))
        y = int(sum(y_list) // len(y_list))
        return x, y

    def _return(self):
        outputs = []
        for id in list(self.objects.keys()):
            outputs.append(
                np.array(
                    [
                        self.bbox[id][0],
                        self.bbox[id][1],
                        self.bbox[id][2],
                        self.bbox[id][3],
                        self.objects[id][0],
                        self.objects[id][1],
                        id,
                    ],
                    dtype=np.int,
                )
            )

        if len(outputs) &gt; 0:
            outputs = np.stack(outputs, axis=0)

        # self.l.debug(outputs)

        return outputs

    def _continueMovement(self, objectID):
        # check if values for the last valid movement is existing (i.e. the object must have been detected at least once in two consecutive frames)
        if self.lastValidMovement[objectID] is not None:
            self.objects[objectID][0] = self.objects[objectID][0] + (
                self.lastValidMovement[objectID][0] * self.time_between_frames
            )
            self.continuedMovement[objectID] = True

    def _isInsideDeregistrationZone(self, centroid):
        if (
            centroid[1] &lt; self.LANE_SEPARATOR and centroid[0] &lt; self.DEREGISTRATION_ZONE
        ) or (
            centroid[1] &gt; self.LANE_SEPARATOR
            and centroid[0] &gt; (self.FRAME_WIDTH - self.DEREGISTRATION_ZONE)
        ):
            return True
        else:
            return False

    def _isNotInsideDeregistrationZone(self, centroid):
        if (
            (
                centroid[1] &lt; self.LANE_SEPARATOR
                and centroid[0] &gt;= self.DEREGISTRATION_ZONE
            )
            or (
                centroid[1] &gt; self.LANE_SEPARATOR
                and centroid[0] &lt;= (self.FRAME_WIDTH - self.DEREGISTRATION_ZONE)
            )
            or self.IGNORE_REGISTRATION_ZONES
        ):
            return True
        else:
            return False

    def _register(self, centroid, bbox, conf):
        # when registering an object we use the next available object
        # ID to store the centroid
        self.objects[self.nextObjectID] = centroid
        self.disappeared[self.nextObjectID] = 0
        # add other information
        self.bbox[self.nextObjectID] = bbox
        self.confidence[self.nextObjectID] = conf
        # Previous group information
        self.previousPos[self.nextObjectID] = centroid
        self.continuedMovement[self.nextObjectID] = False
        self.lastValidMovement[self.nextObjectID] = None
        # increment objectID
        self.nextObjectID += 1

    def _deregister(self, objectID):
        # to deregister an object ID we delete the object ID from
        # all of our respective dictionaries
        del self.objects[objectID]
        del self.disappeared[objectID]
        del self.bbox[objectID]
        del self.confidence[objectID]
        # Previous Group
        del self.previousPos[objectID]
        del self.continuedMovement[objectID]
        del self.lastValidMovement[objectID]

    def update(
        self, det: Type[torch.Tensor], img: Type[np.ndarray]
    ) -&gt; np.ndarray:  # det: list of koordinates x,y , x,y, ...
        # self.l.debug(&#34;UPDATE CENTROID TRACKER&#34;)
        bbox_xyxy, conf, _ = self.transform_detections(det)

        # Previous Group
        # create current timestamp in ms
        frame_timestamp = int(round(time.time() * 1000))

        if self.previous_timestamp is not None and not self.IS_VIDEO_INPUT:
            self.time_between_frames = frame_timestamp - self.previous_timestamp

        # check to see if the list of input bounding box rectangles
        # is empty
        if len(bbox_xyxy) == 0:
            # loop over any existing tracked objects and mark them
            # as disappeared
            for objectID in list(self.disappeared.keys()):
                self.disappeared[objectID] += 1
                # Previous Group
                self.continuedMovement[objectID] = False
                self._continueMovement(objectID)
                self.previousPos[objectID] = None
                # if we have reached a maximum number of consecutive
                # frames where a given object has been marked as
                # missing, deregister it
                # Or if the object is inside the deregistration zone
                if self.disappeared[
                    objectID
                ] &gt; self.MAX_DISAPPEARED or self._isInsideDeregistrationZone(
                    self.objects[objectID]
                ):
                    self._deregister(objectID)
            # return early as there are no centroids or tracking info
            # to update
            self.previous_timestamp = frame_timestamp
            return self._return()

        # initialize an array of input centroids for the current frame
        inputCentroids = np.zeros((len(bbox_xyxy), 2), dtype=&#34;int&#34;)
        inputBBOX = np.zeros((len(bbox_xyxy), 4), dtype=&#34;int&#34;)
        inputConfidence = np.zeros((len(bbox_xyxy), 1), dtype=&#34;float&#34;)
        # loop over the bounding box rectangles
        for (i, bb) in enumerate(bbox_xyxy):
            # use the bounding box coordinates to derive the centroid
            inputCentroids[i] = self._centroid(bb)
            inputBBOX[i] = bb
            inputConfidence[i] = conf[i]

        # print(&#34;INPUTS:&#34;)
        # print(inputCentroids, inputBBOX, inputConfidence)

        # if we are currently not tracking any objects take the input
        # centroids and register each of them
        if len(self.objects) == 0:
            for i in range(len(inputCentroids)):
                # only register when not in deregistration zone
                if self._isNotInsideDeregistrationZone(inputCentroids[i]):
                    self._register(inputCentroids[i], inputBBOX[i], inputConfidence[i])

        # otherwise, are are currently tracking objects so we need to
        # try to match the input centroids to existing object
        # centroids
        else:
            # grab the set of object IDs and corresponding centroids
            objectIDs = list(self.objects.keys())
            objectCentroids = list(self.objects.values())
            # compute the distance between each pair of object
            # centroids and input centroids, respectively -- our
            # goal will be to match an input centroid to an existing
            # object centroid
            D = dist.cdist(np.array(objectCentroids), inputCentroids)
            # Previous Group
            # create sorted list of tuples of indexes and value in ascending order
            D_sorted = sorted(np.ndenumerate(D), key=itemgetter(1))
            # in order to determine if we need to update, register,
            # or deregister an object we need to keep track of which
            # of the rows and column indexes we have already examined
            usedRows = set()
            usedCols = set()

            # loop through pairs of object, inputCentroid, and distance
            for line in D_sorted:
                row = line[0][0]
                col = line[0][1]
                distance = line[1]
                # if we have already examined either the row or
                # column value before, ignore it
                # val
                if row in usedRows or col in usedCols:
                    continue
                # otherwise, grab the object ID for the current row,
                # set its new centroid, and reset the disappeared
                # counter
                # But only if inside a maximum distance
                if (distance &lt; self.DISTANCE_TOLERANCE) and (
                    abs(self.objects[objectIDs[row]][1] - inputCentroids[col][1])
                    &lt; self.VERTICAL_TOLERANCE
                ):
                    objectID = objectIDs[row]
                    self.objects[objectID] = inputCentroids[col]
                    self.bbox[objectID] = inputBBOX[col]
                    self.confidence[objectID] = inputConfidence[col]
                    self.disappeared[objectID] = 0
                    # Previous Group
                    self.continuedMovement[objectID] = False

                    # Previous Group
                    # save the movement between the last two frames (only, if it is &#34;forward&#34;)
                    if self.previousPos[objectID] is not None:
                        if (
                            self.objects[objectID][1] &lt; self.LANE_SEPARATOR
                            and (
                                self.objects[objectID][0]
                                - self.previousPos[objectID][0]
                            )
                            &lt; 0
                        ) or (
                            self.objects[objectID][1] &gt; self.LANE_SEPARATOR
                            and (
                                self.objects[objectID][0]
                                - self.previousPos[objectID][0]
                            )
                            &gt; 0
                        ):

                            self.lastValidMovement[objectID] = (
                                self.objects[objectID] - self.previousPos[objectID]
                            ) / self.time_between_frames
                        self.previousPos[objectID] = self.objects[objectID]

                    # indicate that we have examined each of the row and
                    # column indexes, respectively
                    usedRows.add(row)
                    usedCols.add(col)

            # compute both the row and column index we have NOT yet
            # examined
            unusedRows = set(range(0, D.shape[0])).difference(usedRows)
            unusedCols = set(range(0, D.shape[1])).difference(usedCols)

            # in the event that the number of object centroids is
            # equal or greater than the number of input centroids
            # we need to check and see if some of these objects have
            # potentially disappeared
            if D.shape[0] &gt;= D.shape[1]:
                # loop over the unused row indexes
                for row in unusedRows:
                    # grab the object ID for the corresponding row
                    # index and increment the disappeared counter
                    objectID = objectIDs[row]
                    self.disappeared[objectID] += 1
                    # Previous Group
                    self.continuedMovement[objectID] = False
                    self._continueMovement(objectID)
                    self.previousPos[objectID] = None
                    # check to see if the number of consecutive
                    # frames the object has been marked &#34;disappeared&#34;
                    # for warrants deregistering the object
                    # Or if object is inside deregistration zone
                    if self.disappeared[
                        objectID
                    ] &gt; self.MAX_DISAPPEARED or self._isInsideDeregistrationZone(
                        objectCentroids[row]
                    ):
                        self._deregister(objectID)

            # otherwise, if the number of input centroids is greater
            # than the number of existing object centroids we need to
            # register each new input centroid as a trackable object
            else:
                for col in unusedCols:
                    if self._isNotInsideDeregistrationZone(inputCentroids[col]):
                        self._register(
                            inputCentroids[col], inputBBOX[col], inputConfidence[col]
                        )

        # return the set of trackable objects
        self.previous_timestamp = frame_timestamp
        return self._return()

    @staticmethod
    def transform_detections(det: Type[torch.Tensor]):
        &#34;&#34;&#34;
        Transform detection vector to numpy

        :param det (torch.Tensor): prediction tensor

        :return xyxy (np.ndarray (,4)): x1, y1, x2, y2
                conf (np.ndarray (,1)): class confidences
                cls  (np,ndarray (,1)): class indeces
        &#34;&#34;&#34;
        t_det = det.cpu().detach().numpy()
        return t_det[:, :4], t_det[..., 4], t_det[..., 5]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pancake.tracker.tracker.BaseTracker" href="tracker.html#pancake.tracker.tracker.BaseTracker">BaseTracker</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pancake.tracker.tracker_centroid_old.CentroidTracker.transform_detections"><code class="name flex">
<span>def <span class="ident">transform_detections</span></span>(<span>det: Type[torch.Tensor])</span>
</code></dt>
<dd>
<div class="desc"><p>Transform detection vector to numpy</p>
<p>:param det (torch.Tensor): prediction tensor</p>
<p>:return xyxy (np.ndarray (,4)): x1, y1, x2, y2
conf (np.ndarray (,1)): class confidences
cls
(np,ndarray (,1)): class indeces</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def transform_detections(det: Type[torch.Tensor]):
    &#34;&#34;&#34;
    Transform detection vector to numpy

    :param det (torch.Tensor): prediction tensor

    :return xyxy (np.ndarray (,4)): x1, y1, x2, y2
            conf (np.ndarray (,1)): class confidences
            cls  (np,ndarray (,1)): class indeces
    &#34;&#34;&#34;
    t_det = det.cpu().detach().numpy()
    return t_det[:, :4], t_det[..., 4], t_det[..., 5]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pancake.tracker.tracker_centroid_old.CentroidTracker.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, det: Type[torch.Tensor], img: Type[numpy.ndarray]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(
    self, det: Type[torch.Tensor], img: Type[np.ndarray]
) -&gt; np.ndarray:  # det: list of koordinates x,y , x,y, ...
    # self.l.debug(&#34;UPDATE CENTROID TRACKER&#34;)
    bbox_xyxy, conf, _ = self.transform_detections(det)

    # Previous Group
    # create current timestamp in ms
    frame_timestamp = int(round(time.time() * 1000))

    if self.previous_timestamp is not None and not self.IS_VIDEO_INPUT:
        self.time_between_frames = frame_timestamp - self.previous_timestamp

    # check to see if the list of input bounding box rectangles
    # is empty
    if len(bbox_xyxy) == 0:
        # loop over any existing tracked objects and mark them
        # as disappeared
        for objectID in list(self.disappeared.keys()):
            self.disappeared[objectID] += 1
            # Previous Group
            self.continuedMovement[objectID] = False
            self._continueMovement(objectID)
            self.previousPos[objectID] = None
            # if we have reached a maximum number of consecutive
            # frames where a given object has been marked as
            # missing, deregister it
            # Or if the object is inside the deregistration zone
            if self.disappeared[
                objectID
            ] &gt; self.MAX_DISAPPEARED or self._isInsideDeregistrationZone(
                self.objects[objectID]
            ):
                self._deregister(objectID)
        # return early as there are no centroids or tracking info
        # to update
        self.previous_timestamp = frame_timestamp
        return self._return()

    # initialize an array of input centroids for the current frame
    inputCentroids = np.zeros((len(bbox_xyxy), 2), dtype=&#34;int&#34;)
    inputBBOX = np.zeros((len(bbox_xyxy), 4), dtype=&#34;int&#34;)
    inputConfidence = np.zeros((len(bbox_xyxy), 1), dtype=&#34;float&#34;)
    # loop over the bounding box rectangles
    for (i, bb) in enumerate(bbox_xyxy):
        # use the bounding box coordinates to derive the centroid
        inputCentroids[i] = self._centroid(bb)
        inputBBOX[i] = bb
        inputConfidence[i] = conf[i]

    # print(&#34;INPUTS:&#34;)
    # print(inputCentroids, inputBBOX, inputConfidence)

    # if we are currently not tracking any objects take the input
    # centroids and register each of them
    if len(self.objects) == 0:
        for i in range(len(inputCentroids)):
            # only register when not in deregistration zone
            if self._isNotInsideDeregistrationZone(inputCentroids[i]):
                self._register(inputCentroids[i], inputBBOX[i], inputConfidence[i])

    # otherwise, are are currently tracking objects so we need to
    # try to match the input centroids to existing object
    # centroids
    else:
        # grab the set of object IDs and corresponding centroids
        objectIDs = list(self.objects.keys())
        objectCentroids = list(self.objects.values())
        # compute the distance between each pair of object
        # centroids and input centroids, respectively -- our
        # goal will be to match an input centroid to an existing
        # object centroid
        D = dist.cdist(np.array(objectCentroids), inputCentroids)
        # Previous Group
        # create sorted list of tuples of indexes and value in ascending order
        D_sorted = sorted(np.ndenumerate(D), key=itemgetter(1))
        # in order to determine if we need to update, register,
        # or deregister an object we need to keep track of which
        # of the rows and column indexes we have already examined
        usedRows = set()
        usedCols = set()

        # loop through pairs of object, inputCentroid, and distance
        for line in D_sorted:
            row = line[0][0]
            col = line[0][1]
            distance = line[1]
            # if we have already examined either the row or
            # column value before, ignore it
            # val
            if row in usedRows or col in usedCols:
                continue
            # otherwise, grab the object ID for the current row,
            # set its new centroid, and reset the disappeared
            # counter
            # But only if inside a maximum distance
            if (distance &lt; self.DISTANCE_TOLERANCE) and (
                abs(self.objects[objectIDs[row]][1] - inputCentroids[col][1])
                &lt; self.VERTICAL_TOLERANCE
            ):
                objectID = objectIDs[row]
                self.objects[objectID] = inputCentroids[col]
                self.bbox[objectID] = inputBBOX[col]
                self.confidence[objectID] = inputConfidence[col]
                self.disappeared[objectID] = 0
                # Previous Group
                self.continuedMovement[objectID] = False

                # Previous Group
                # save the movement between the last two frames (only, if it is &#34;forward&#34;)
                if self.previousPos[objectID] is not None:
                    if (
                        self.objects[objectID][1] &lt; self.LANE_SEPARATOR
                        and (
                            self.objects[objectID][0]
                            - self.previousPos[objectID][0]
                        )
                        &lt; 0
                    ) or (
                        self.objects[objectID][1] &gt; self.LANE_SEPARATOR
                        and (
                            self.objects[objectID][0]
                            - self.previousPos[objectID][0]
                        )
                        &gt; 0
                    ):

                        self.lastValidMovement[objectID] = (
                            self.objects[objectID] - self.previousPos[objectID]
                        ) / self.time_between_frames
                    self.previousPos[objectID] = self.objects[objectID]

                # indicate that we have examined each of the row and
                # column indexes, respectively
                usedRows.add(row)
                usedCols.add(col)

        # compute both the row and column index we have NOT yet
        # examined
        unusedRows = set(range(0, D.shape[0])).difference(usedRows)
        unusedCols = set(range(0, D.shape[1])).difference(usedCols)

        # in the event that the number of object centroids is
        # equal or greater than the number of input centroids
        # we need to check and see if some of these objects have
        # potentially disappeared
        if D.shape[0] &gt;= D.shape[1]:
            # loop over the unused row indexes
            for row in unusedRows:
                # grab the object ID for the corresponding row
                # index and increment the disappeared counter
                objectID = objectIDs[row]
                self.disappeared[objectID] += 1
                # Previous Group
                self.continuedMovement[objectID] = False
                self._continueMovement(objectID)
                self.previousPos[objectID] = None
                # check to see if the number of consecutive
                # frames the object has been marked &#34;disappeared&#34;
                # for warrants deregistering the object
                # Or if object is inside deregistration zone
                if self.disappeared[
                    objectID
                ] &gt; self.MAX_DISAPPEARED or self._isInsideDeregistrationZone(
                    objectCentroids[row]
                ):
                    self._deregister(objectID)

        # otherwise, if the number of input centroids is greater
        # than the number of existing object centroids we need to
        # register each new input centroid as a trackable object
        else:
            for col in unusedCols:
                if self._isNotInsideDeregistrationZone(inputCentroids[col]):
                    self._register(
                        inputCentroids[col], inputBBOX[col], inputConfidence[col]
                    )

    # return the set of trackable objects
    self.previous_timestamp = frame_timestamp
    return self._return()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pancake.tracker" href="index.html">pancake.tracker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pancake.tracker.tracker_centroid_old.CentroidTracker" href="#pancake.tracker.tracker_centroid_old.CentroidTracker">CentroidTracker</a></code></h4>
<ul class="">
<li><code><a title="pancake.tracker.tracker_centroid_old.CentroidTracker.transform_detections" href="#pancake.tracker.tracker_centroid_old.CentroidTracker.transform_detections">transform_detections</a></code></li>
<li><code><a title="pancake.tracker.tracker_centroid_old.CentroidTracker.update" href="#pancake.tracker.tracker_centroid_old.CentroidTracker.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>