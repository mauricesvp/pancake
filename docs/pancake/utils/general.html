<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pancake.utils.general API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pancake.utils.general</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># YOLOv5 general utils

import glob
import math
import os
import platform
import random
import re
import subprocess
import time
from itertools import repeat
from multiprocessing.pool import ThreadPool
from pathlib import Path

import cv2
import numpy as np
import onnx
import pandas as pd
import torch
import torchvision
import yaml

from .google_utils import gsutil_getsize
from .metrics import fitness
from .torch_utils import init_torch_seeds

from pancake.logger import setup_logger

l = setup_logger(__name__)

# Settings
torch.set_printoptions(linewidth=320, precision=5, profile=&#34;long&#34;)
np.set_printoptions(
    linewidth=320, formatter={&#34;float_kind&#34;: &#34;{:11.5g}&#34;.format}
)  # format short g, %precision=5
pd.options.display.max_columns = 10
# cv2.setNumThreads(
#     0
# )  # prevent OpenCV from multithreading (incompatible with PyTorch DataLoader)
os.environ[&#34;NUMEXPR_MAX_THREADS&#34;] = str(min(os.cpu_count(), 8))  # NumExpr max threads


def set_logging(rank=-1, verbose=True):
    raise DeprecationWarning(&#34;Use pancake.logger instead!&#34;)
    # logging.basicConfig(
    # format=&#34;%(message)s&#34;,
    # level=logging.INFO if (verbose and rank in [-1, 0]) else logging.WARN,
    # )


def init_seeds(seed=0):
    # Initialize random number generator (RNG) seeds
    random.seed(seed)
    np.random.seed(seed)
    init_torch_seeds(seed)


def get_latest_run(search_dir=&#34;.&#34;):
    # Return path to most recent &#39;last.pt&#39; in /runs (i.e. to --resume from)
    last_list = glob.glob(f&#34;{search_dir}/**/last*.pt&#34;, recursive=True)
    return max(last_list, key=os.path.getctime) if last_list else &#34;&#34;


def is_docker():
    # Is environment a Docker container
    return Path(&#34;/workspace&#34;).exists()  # or Path(&#39;/.dockerenv&#39;).exists()


def is_colab():
    # Is environment a Google Colab instance
    try:
        import google.colab

        return True
    except Exception as e:
        return False


def emojis(str=&#34;&#34;):
    # Return platform-dependent emoji-safe version of string
    return (
        str.encode().decode(&#34;ascii&#34;, &#34;ignore&#34;)
        if platform.system() == &#34;Windows&#34;
        else str
    )


def file_size(file):
    # Return file size in MB
    return Path(file).stat().st_size / 1e6


def check_online():
    # Check internet connectivity
    import socket

    try:
        socket.create_connection((&#34;1.1.1.1&#34;, 443), 5)  # check host accesability
        return True
    except OSError:
        return False


def check_git_status():
    # Recommend &#39;git pull&#39; if code is out of date
    l.debug(colorstr(&#34;github: &#34;))
    try:
        assert Path(&#34;.git&#34;).exists(), &#34;skipping check (not a git repository)&#34;
        assert not is_docker(), &#34;skipping check (Docker image)&#34;
        assert check_online(), &#34;skipping check (offline)&#34;

        cmd = &#34;git fetch &amp;&amp; git config --get remote.origin.url&#34;
        url = (
            subprocess.check_output(cmd, shell=True).decode().strip().rstrip(&#34;.git&#34;)
        )  # github repo url
        branch = (
            subprocess.check_output(&#34;git rev-parse --abbrev-ref HEAD&#34;, shell=True)
            .decode()
            .strip()
        )  # checked out
        n = int(
            subprocess.check_output(
                f&#34;git rev-list {branch}..origin/master --count&#34;, shell=True
            )
        )  # commits behind
        if n &gt; 0:
            s = (
                f&#34;⚠️ WARNING: code is out of date by {n} commit{&#39;s&#39; * (n &gt; 1)}. &#34;
                f&#34;Use &#39;git pull&#39; to update or &#39;git clone {url}&#39; to download latest.&#34;
            )
        else:
            s = f&#34;up to date with {url} ✅&#34;
        l.debug(emojis(s))  # emoji-safe
    except Exception as e:
        l.debug(e)


def check_requirements(requirements=&#34;requirements.txt&#34;, exclude=()):
    # Check installed dependencies meet requirements (pass *.txt file or list of packages)
    import pkg_resources as pkg

    prefix = colorstr(&#34;red&#34;, &#34;bold&#34;, &#34;requirements:&#34;)
    if isinstance(requirements, (str, Path)):  # requirements.txt file
        file = Path(requirements)
        if not file.exists():
            print(f&#34;{prefix} {file.resolve()} not found, check failed.&#34;)
            return
        requirements = [
            f&#34;{x.name}{x.specifier}&#34;
            for x in pkg.parse_requirements(file.open())
            if x.name not in exclude
        ]
    else:  # list or tuple of packages
        requirements = [x for x in requirements if x not in exclude]

    n = 0  # number of packages updates
    for r in requirements:
        try:
            pkg.require(r)
        except Exception as e:  # DistributionNotFound or VersionConflict if requirements not met
            n += 1
            print(
                f&#34;{prefix} {r} not found and is required by pancake, attempting auto-update...&#34;
            )
            print(subprocess.check_output(f&#34;pip install &#39;{r}&#39;&#34;, shell=True).decode())

    if n:  # if packages updated
        source = file.resolve() if &#34;file&#34; in locals() else requirements
        s = (
            f&#34;{prefix} {n} package{&#39;s&#39; * (n &gt; 1)} updated per {source}\n&#34;
            f&#34;{prefix} ⚠️ {colorstr(&#39;bold&#39;, &#39;Restart runtime or rerun command for updates to take effect&#39;)}\n&#34;
        )
        print(emojis(s))  # emoji-safe


def check_img_size(img_size, s=32):
    # Verify img_size is a multiple of stride s
    new_size = make_divisible(img_size, int(s))  # ceil gs-multiple
    if new_size != img_size:
        print(
            &#34;WARNING: --img-size %g must be multiple of max stride %g, updating to %g&#34;
            % (img_size, s, new_size)
        )
    return new_size


def check_imshow():
    # Check if environment supports image displays
    try:
        assert not is_docker(), &#34;cv2.imshow() is disabled in Docker environments&#34;
        assert not is_colab(), &#34;cv2.imshow() is disabled in Google Colab environments&#34;
        cv2.imshow(&#34;test&#34;, np.zeros((1, 1, 3)))
        cv2.waitKey(1)
        cv2.destroyAllWindows()
        cv2.waitKey(1)
        return True
    except Exception as e:
        print(
            f&#34;WARNING: Environment does not support cv2.imshow() or PIL Image.show() image displays\n{e}&#34;
        )
        return False


def check_file(file):
    # Search for file if not found
    if Path(file).is_file() or file == &#34;&#34;:
        return file
    else:
        files = glob.glob(&#34;./**/&#34; + file, recursive=True)  # find file
        assert len(files), f&#34;File Not Found: {file}&#34;  # assert file was found
        assert (
            len(files) == 1
        ), f&#34;Multiple files match &#39;{file}&#39;, specify exact path: {files}&#34;  # assert unique
        return files[0]  # return file


def check_dataset(dict):
    # Download dataset if not found locally
    val, s = dict.get(&#34;val&#34;), dict.get(&#34;download&#34;)
    if val and len(val):
        val = [
            Path(x).resolve() for x in (val if isinstance(val, list) else [val])
        ]  # val path
        if not all(x.exists() for x in val):
            print(
                &#34;\nWARNING: Dataset not found, nonexistent paths: %s&#34;
                % [str(x) for x in val if not x.exists()]
            )
            if s and len(s):  # download script
                if s.startswith(&#34;http&#34;) and s.endswith(&#34;.zip&#34;):  # URL
                    f = Path(s).name  # filename
                    print(f&#34;Downloading {s} ...&#34;)
                    torch.hub.download_url_to_file(s, f)
                    r = os.system(f&#34;unzip -q {f} -d ../ &amp;&amp; rm {f}&#34;)  # unzip
                elif s.startswith(&#34;bash &#34;):  # bash script
                    print(f&#34;Running {s} ...&#34;)
                    r = os.system(s)
                else:  # python script
                    r = exec(s)  # return None
                print(
                    &#34;Dataset autodownload %s\n&#34;
                    % (&#34;success&#34; if r in (0, None) else &#34;failure&#34;)
                )  # print result
            else:
                raise Exception(&#34;Dataset not found.&#34;)


def download(url, dir=&#34;.&#34;, unzip=True, delete=True, curl=False, threads=1):
    # Multi-threaded file download and unzip function
    def download_one(url, dir):
        # Download 1 file
        f = dir / Path(url).name  # filename
        if not f.exists():
            print(f&#34;Downloading {url} to {f}...&#34;)
            if curl:
                os.system(
                    f&#34;curl -L &#39;{url}&#39; -o &#39;{f}&#39; --retry 9 -C -&#34;
                )  # curl download, retry and resume on fail
            else:
                torch.hub.download_url_to_file(url, f, progress=True)  # torch download
        if unzip and f.suffix in (&#34;.zip&#34;, &#34;.gz&#34;):
            print(f&#34;Unzipping {f}...&#34;)
            if f.suffix == &#34;.zip&#34;:
                s = f&#34;unzip -qo {f} -d {dir} &amp;&amp; rm {f}&#34;  # unzip -quiet -overwrite
            elif f.suffix == &#34;.gz&#34;:
                s = f&#34;tar xfz {f} --directory {f.parent}&#34;  # unzip
            if delete:  # delete zip file after unzip
                s += f&#34; &amp;&amp; rm {f}&#34;
            os.system(s)

    dir = Path(dir)
    dir.mkdir(parents=True, exist_ok=True)  # make directory
    if threads &gt; 1:
        pool = ThreadPool(threads)
        pool.imap(lambda x: download_one(*x), zip(url, repeat(dir)))  # multi-threaded
        pool.close()
        pool.join()
    else:
        for u in tuple(url) if isinstance(url, str) else url:
            download_one(u, dir)


def make_divisible(x, divisor):
    # Returns x evenly divisible by divisor
    return math.ceil(x / divisor) * divisor


def clean_str(s):
    # Cleans a string by replacing special characters with underscore _
    return re.sub(pattern=&#34;[|@#!¡·$€%&amp;()=?¿^*;:,¨´&gt;&lt;+]&#34;, repl=&#34;_&#34;, string=s)


def one_cycle(y1=0.0, y2=1.0, steps=100):
    # lambda function for sinusoidal ramp from y1 to y2
    return lambda x: ((1 - math.cos(x * math.pi / steps)) / 2) * (y2 - y1) + y1


def colorstr(*input):
    # Colors a string https://en.wikipedia.org/wiki/ANSI_escape_code, i.e.  colorstr(&#39;blue&#39;, &#39;hello world&#39;)
    *args, string = (
        input if len(input) &gt; 1 else (&#34;blue&#34;, &#34;bold&#34;, input[0])
    )  # color arguments, string
    colors = {
        &#34;black&#34;: &#34;\033[30m&#34;,  # basic colors
        &#34;red&#34;: &#34;\033[31m&#34;,
        &#34;green&#34;: &#34;\033[32m&#34;,
        &#34;yellow&#34;: &#34;\033[33m&#34;,
        &#34;blue&#34;: &#34;\033[34m&#34;,
        &#34;magenta&#34;: &#34;\033[35m&#34;,
        &#34;cyan&#34;: &#34;\033[36m&#34;,
        &#34;white&#34;: &#34;\033[37m&#34;,
        &#34;bright_black&#34;: &#34;\033[90m&#34;,  # bright colors
        &#34;bright_red&#34;: &#34;\033[91m&#34;,
        &#34;bright_green&#34;: &#34;\033[92m&#34;,
        &#34;bright_yellow&#34;: &#34;\033[93m&#34;,
        &#34;bright_blue&#34;: &#34;\033[94m&#34;,
        &#34;bright_magenta&#34;: &#34;\033[95m&#34;,
        &#34;bright_cyan&#34;: &#34;\033[96m&#34;,
        &#34;bright_white&#34;: &#34;\033[97m&#34;,
        &#34;end&#34;: &#34;\033[0m&#34;,  # misc
        &#34;bold&#34;: &#34;\033[1m&#34;,
        &#34;underline&#34;: &#34;\033[4m&#34;,
    }
    return &#34;&#34;.join(colors[x] for x in args) + f&#34;{string}&#34; + colors[&#34;end&#34;]


def labels_to_class_weights(labels, nc=80):
    # Get class weights (inverse frequency) from training labels
    if labels[0] is None:  # no labels loaded
        return torch.Tensor()

    labels = np.concatenate(labels, 0)  # labels.shape = (866643, 5) for COCO
    classes = labels[:, 0].astype(np.int)  # labels = [class xywh]
    weights = np.bincount(classes, minlength=nc)  # occurrences per class

    # Prepend gridpoint count (for uCE training)
    # gpi = ((320 / 32 * np.array([1, 2, 4])) ** 2 * 3).sum()  # gridpoints per image
    # weights = np.hstack([gpi * len(labels)  - weights.sum() * 9, weights * 9]) ** 0.5  # prepend gridpoints to start

    weights[weights == 0] = 1  # replace empty bins with 1
    weights = 1 / weights  # number of targets per class
    weights /= weights.sum()  # normalize
    return torch.from_numpy(weights)


def labels_to_image_weights(labels, nc=80, class_weights=np.ones(80)):
    # Produces image weights based on class_weights and image contents
    class_counts = np.array(
        [np.bincount(x[:, 0].astype(np.int), minlength=nc) for x in labels]
    )
    image_weights = (class_weights.reshape(1, nc) * class_counts).sum(1)
    # index = random.choices(range(n), weights=image_weights, k=1)  # weight image sample
    return image_weights


def coco80_to_coco91_class():  # converts 80-index (val2014) to 91-index (paper)
    # https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/
    # a = np.loadtxt(&#39;data/coco.names&#39;, dtype=&#39;str&#39;, delimiter=&#39;\n&#39;)
    # b = np.loadtxt(&#39;data/coco_paper.names&#39;, dtype=&#39;str&#39;, delimiter=&#39;\n&#39;)
    # x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco
    # x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet
    x = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        27,
        28,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        67,
        70,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
    ]
    return x


def xyxy2xywh(x):
    # Convert nx4 boxes from [x1, y1, x2, y2] to [x, y, w, h] where xy1=top-left, xy2=bottom-right
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = (x[:, 0] + x[:, 2]) / 2  # x center
    y[:, 1] = (x[:, 1] + x[:, 3]) / 2  # y center
    y[:, 2] = x[:, 2] - x[:, 0]  # width
    y[:, 3] = x[:, 3] - x[:, 1]  # height
    return y


def xywh2xyxy(x):
    # Convert nx4 boxes from [x, y, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = x[:, 0] - x[:, 2] / 2  # top left x
    y[:, 1] = x[:, 1] - x[:, 3] / 2  # top left y
    y[:, 2] = x[:, 0] + x[:, 2] / 2  # bottom right x
    y[:, 3] = x[:, 1] + x[:, 3] / 2  # bottom right y
    return y


def xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):
    # Convert nx4 boxes from [x, y, w, h] normalized to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = w * (x[:, 0] - x[:, 2] / 2) + padw  # top left x
    y[:, 1] = h * (x[:, 1] - x[:, 3] / 2) + padh  # top left y
    y[:, 2] = w * (x[:, 0] + x[:, 2] / 2) + padw  # bottom right x
    y[:, 3] = h * (x[:, 1] + x[:, 3] / 2) + padh  # bottom right y
    return y


def xyn2xy(x, w=640, h=640, padw=0, padh=0):
    # Convert normalized segments into pixel segments, shape (n,2)
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = w * x[:, 0] + padw  # top left x
    y[:, 1] = h * x[:, 1] + padh  # top left y
    return y


def segment2box(segment, width=640, height=640):
    # Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy)
    x, y = segment.T  # segment xy
    inside = (x &gt;= 0) &amp; (y &gt;= 0) &amp; (x &lt;= width) &amp; (y &lt;= height)
    x, y, = (
        x[inside],
        y[inside],
    )
    return (
        np.array([x.min(), y.min(), x.max(), y.max()]) if any(x) else np.zeros((1, 4))
    )  # xyxy


def segments2boxes(segments):
    # Convert segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)
    boxes = []
    for s in segments:
        x, y = s.T  # segment xy
        boxes.append([x.min(), y.min(), x.max(), y.max()])  # cls, xyxy
    return xyxy2xywh(np.array(boxes))  # cls, xywh


def resample_segments(segments, n=1000):
    # Up-sample an (n,2) segment
    for i, s in enumerate(segments):
        x = np.linspace(0, len(s) - 1, n)
        xp = np.arange(len(s))
        segments[i] = (
            np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)])
            .reshape(2, -1)
            .T
        )  # segment xy
    return segments


def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None):
    # Rescale coords (xyxy) from img1_shape to img0_shape
    if ratio_pad is None:  # calculate from img0_shape
        gain = min(
            img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1]
        )  # gain  = old / new
        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (
            img1_shape[0] - img0_shape[0] * gain
        ) / 2  # wh padding
    else:
        gain = ratio_pad[0][0]
        pad = ratio_pad[1]

    coords[:, [0, 2]] -= pad[0]  # x padding
    coords[:, [1, 3]] -= pad[1]  # y padding
    coords[:, :4] /= gain
    clip_coords(coords, img0_shape)
    return coords


def clip_coords(boxes, img_shape):
    # Clip bounding xyxy bounding boxes to image shape (height, width)
    boxes[:, 0].clamp_(0, img_shape[1])  # x1
    boxes[:, 1].clamp_(0, img_shape[0])  # y1
    boxes[:, 2].clamp_(0, img_shape[1])  # x2
    boxes[:, 3].clamp_(0, img_shape[0])  # y2


def bbox_iou(box1, box2, x1y1x2y2=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):
    # Returns the IoU of box1 to box2. box1 is 4, box2 is nx4
    box2 = box2.T

    # Get the coordinates of bounding boxes
    if x1y1x2y2:  # x1, y1, x2, y2 = box1
        b1_x1, b1_y1, b1_x2, b1_y2 = box1[0], box1[1], box1[2], box1[3]
        b2_x1, b2_y1, b2_x2, b2_y2 = box2[0], box2[1], box2[2], box2[3]
    else:  # transform from xywh to xyxy
        b1_x1, b1_x2 = box1[0] - box1[2] / 2, box1[0] + box1[2] / 2
        b1_y1, b1_y2 = box1[1] - box1[3] / 2, box1[1] + box1[3] / 2
        b2_x1, b2_x2 = box2[0] - box2[2] / 2, box2[0] + box2[2] / 2
        b2_y1, b2_y2 = box2[1] - box2[3] / 2, box2[1] + box2[3] / 2

    # Intersection area
    inter = (torch.min(b1_x2, b2_x2) - torch.max(b1_x1, b2_x1)).clamp(0) * (
        torch.min(b1_y2, b2_y2) - torch.max(b1_y1, b2_y1)
    ).clamp(0)

    # Union Area
    w1, h1 = b1_x2 - b1_x1, b1_y2 - b1_y1 + eps
    w2, h2 = b2_x2 - b2_x1, b2_y2 - b2_y1 + eps
    union = w1 * h1 + w2 * h2 - inter + eps

    iou = inter / union
    if GIoU or DIoU or CIoU:
        cw = torch.max(b1_x2, b2_x2) - torch.min(
            b1_x1, b2_x1
        )  # convex (smallest enclosing box) width
        ch = torch.max(b1_y2, b2_y2) - torch.min(b1_y1, b2_y1)  # convex height
        if CIoU or DIoU:  # Distance or Complete IoU https://arxiv.org/abs/1911.08287v1
            c2 = cw ** 2 + ch ** 2 + eps  # convex diagonal squared
            rho2 = (
                (b2_x1 + b2_x2 - b1_x1 - b1_x2) ** 2
                + (b2_y1 + b2_y2 - b1_y1 - b1_y2) ** 2
            ) / 4  # center distance squared
            if DIoU:
                return iou - rho2 / c2  # DIoU
            elif (
                CIoU
            ):  # https://github.com/Zzh-tju/DIoU-SSD-pytorch/blob/master/utils/box/box_utils.py#L47
                v = (4 / math.pi ** 2) * torch.pow(
                    torch.atan(w2 / h2) - torch.atan(w1 / h1), 2
                )
                with torch.no_grad():
                    alpha = v / (v - iou + (1 + eps))
                return iou - (rho2 / c2 + v * alpha)  # CIoU
        else:  # GIoU https://arxiv.org/pdf/1902.09630.pdf
            c_area = cw * ch + eps  # convex area
            return iou - (c_area - union) / c_area  # GIoU
    else:
        return iou  # IoU


def box_iou(box1, box2):
    # https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py
    &#34;&#34;&#34;
    Return intersection-over-union (Jaccard index) of boxes.
    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
    Arguments:
        box1 (Tensor[N, 4])
        box2 (Tensor[M, 4])
    Returns:
        iou (Tensor[N, M]): the NxM matrix containing the pairwise
            IoU values for every element in boxes1 and boxes2
    &#34;&#34;&#34;

    def box_area(box):
        # box = 4xn
        return (box[2] - box[0]) * (box[3] - box[1])

    area1 = box_area(box1.T)
    area2 = box_area(box2.T)

    # inter(N,M) = (rb(N,M,2) - lt(N,M,2)).clamp(0).prod(2)
    inter = (
        (
            torch.min(box1[:, None, 2:], box2[:, 2:])
            - torch.max(box1[:, None, :2], box2[:, :2])
        )
        .clamp(0)
        .prod(2)
    )
    return inter / (
        area1[:, None] + area2 - inter
    )  # iou = inter / (area1 + area2 - inter)


def wh_iou(wh1, wh2):
    # Returns the nxm IoU matrix. wh1 is nx2, wh2 is mx2
    wh1 = wh1[:, None]  # [N,1,2]
    wh2 = wh2[None]  # [1,M,2]
    inter = torch.min(wh1, wh2).prod(2)  # [N,M]
    return inter / (
        wh1.prod(2) + wh2.prod(2) - inter
    )  # iou = inter / (area1 + area2 - inter)


def non_max_suppression(
    prediction,
    conf_thres=0.25,
    iou_thres=0.45,
    classes=None,
    agnostic=False,
    multi_label=False,
    max_det=300,
    labels=(),
):
    &#34;&#34;&#34;Runs Non-Maximum Suppression (NMS) on inference results

    Returns:
         list of detections, on (n,6) tensor per image [xyxy, conf, cls]
    &#34;&#34;&#34;

    nc = prediction.shape[2] - 5  # number of classes
    xc = prediction[..., 4] &gt; conf_thres  # candidates

    # Checks
    assert (
        0 &lt;= conf_thres &lt;= 1
    ), f&#34;Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0&#34;
    assert (
        0 &lt;= iou_thres &lt;= 1
    ), f&#34;Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0&#34;

    # Settings
    min_wh, max_wh = 2, 4096  # (pixels) minimum and maximum box width and height
    max_nms = 30000  # maximum number of boxes into torchvision.ops.nms()
    time_limit = 10.0  # seconds to quit after
    redundant = True  # require redundant detections
    multi_label &amp;= nc &gt; 1  # multiple labels per box (adds 0.5ms/img)
    merge = False  # use merge-NMS

    t = time.time()
    output = [torch.zeros((0, 6), device=prediction.device)] * prediction.shape[0]
    for xi, x in enumerate(prediction):  # image index, image inference
        # Apply constraints
        # x[((x[..., 2:4] &lt; min_wh) | (x[..., 2:4] &gt; max_wh)).any(1), 4] = 0  # width-height
        x = x[xc[xi]]  # confidence

        # Cat apriori labels if autolabelling
        if labels and len(labels[xi]):
            l = labels[xi]
            v = torch.zeros((len(l), nc + 5), device=x.device)
            v[:, :4] = l[:, 1:5]  # box
            v[:, 4] = 1.0  # conf
            v[range(len(l)), l[:, 0].long() + 5] = 1.0  # cls
            x = torch.cat((x, v), 0)

        # If none remain process next image
        if not x.shape[0]:
            continue

        # Compute conf
        x[:, 5:] *= x[:, 4:5]  # conf = obj_conf * cls_conf

        # Box (center x, center y, width, height) to (x1, y1, x2, y2)
        box = xywh2xyxy(x[:, :4])

        # Detections matrix nx6 (xyxy, conf, cls)
        if multi_label:
            i, j = (x[:, 5:] &gt; conf_thres).nonzero(as_tuple=False).T
            x = torch.cat((box[i], x[i, j + 5, None], j[:, None].float()), 1)
        else:  # best class only
            conf, j = x[:, 5:].max(1, keepdim=True)
            x = torch.cat((box, conf, j.float()), 1)[conf.view(-1) &gt; conf_thres]

        # Filter by class
        if classes is not None:
            x = x[(x[:, 5:6] == torch.tensor(classes, device=x.device)).any(1)]

        # Apply finite constraint
        # if not torch.isfinite(x).all():
        #     x = x[torch.isfinite(x).all(1)]

        # Check shape
        n = x.shape[0]  # number of boxes
        if not n:  # no boxes
            continue
        elif n &gt; max_nms:  # excess boxes
            x = x[x[:, 4].argsort(descending=True)[:max_nms]]  # sort by confidence

        # Batched NMS
        c = x[:, 5:6] * (0 if agnostic else max_wh)  # classes
        boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores
        i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS
        if i.shape[0] &gt; max_det:  # limit detections
            i = i[:max_det]
        if merge and (1 &lt; n &lt; 3e3):  # Merge NMS (boxes merged using weighted mean)
            # update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)
            iou = box_iou(boxes[i], boxes) &gt; iou_thres  # iou matrix
            weights = iou * scores[None]  # box weights
            x[i, :4] = torch.mm(weights, x[:, :4]).float() / weights.sum(
                1, keepdim=True
            )  # merged boxes
            if redundant:
                i = i[iou.sum(1) &gt; 1]  # require redundancy

        output[xi] = x[i]
        if (time.time() - t) &gt; time_limit:
            print(f&#34;WARNING: NMS time limit {time_limit}s exceeded&#34;)
            break  # time limit exceeded

    return output


def strip_optimizer(
    f=&#34;best.pt&#34;, s=&#34;&#34;
):  # from utils.general import *; strip_optimizer()
    # Strip optimizer from &#39;f&#39; to finalize training, optionally save as &#39;s&#39;
    x = torch.load(f, map_location=torch.device(&#34;cpu&#34;))
    if x.get(&#34;ema&#34;):
        x[&#34;model&#34;] = x[&#34;ema&#34;]  # replace model with ema
    for k in &#34;optimizer&#34;, &#34;training_results&#34;, &#34;wandb_id&#34;, &#34;ema&#34;, &#34;updates&#34;:  # keys
        x[k] = None
    x[&#34;epoch&#34;] = -1
    x[&#34;model&#34;].half()  # to FP16
    for p in x[&#34;model&#34;].parameters():
        p.requires_grad = False
    torch.save(x, s or f)
    mb = os.path.getsize(s or f) / 1e6  # filesize
    print(
        f&#34;Optimizer stripped from {f},{(&#39; saved as %s,&#39; % s) if s else &#39;&#39;} {mb:.1f}MB&#34;
    )


def print_mutation(hyp, results, yaml_file=&#34;hyp_evolved.yaml&#34;, bucket=&#34;&#34;):
    # Print mutation results to evolve.txt (for use with train.py --evolve)
    a = &#34;%10s&#34; * len(hyp) % tuple(hyp.keys())  # hyperparam keys
    b = &#34;%10.3g&#34; * len(hyp) % tuple(hyp.values())  # hyperparam values
    c = (
        &#34;%10.4g&#34; * len(results) % results
    )  # results (P, R, mAP@0.5, mAP@0.5:0.95, val_losses x 3)
    print(&#34;\n%s\n%s\nEvolved fitness: %s\n&#34; % (a, b, c))

    if bucket:
        url = &#34;gs://%s/evolve.txt&#34; % bucket
        if gsutil_getsize(url) &gt; (
            os.path.getsize(&#34;evolve.txt&#34;) if os.path.exists(&#34;evolve.txt&#34;) else 0
        ):
            os.system(
                &#34;gsutil cp %s .&#34; % url
            )  # download evolve.txt if larger than local

    with open(&#34;evolve.txt&#34;, &#34;a&#34;) as f:  # append result
        f.write(c + b + &#34;\n&#34;)
    x = np.unique(np.loadtxt(&#34;evolve.txt&#34;, ndmin=2), axis=0)  # load unique rows
    x = x[np.argsort(-fitness(x))]  # sort
    np.savetxt(&#34;evolve.txt&#34;, x, &#34;%10.3g&#34;)  # save sort by fitness

    # Save yaml
    for i, k in enumerate(hyp.keys()):
        hyp[k] = float(x[0, i + 7])
    with open(yaml_file, &#34;w&#34;) as f:
        results = tuple(x[0, :7])
        c = (
            &#34;%10.4g&#34; * len(results) % results
        )  # results (P, R, mAP@0.5, mAP@0.5:0.95, val_losses x 3)
        f.write(
            &#34;# Hyperparameter Evolution Results\n# Generations: %g\n# Metrics: &#34;
            % len(x)
            + c
            + &#34;\n\n&#34;
        )
        yaml.safe_dump(hyp, f, sort_keys=False)

    if bucket:
        os.system(&#34;gsutil cp evolve.txt %s gs://%s&#34; % (yaml_file, bucket))  # upload


def apply_classifier(x, model, img, im0):
    # Apply a second stage classifier to yolo outputs
    im0 = [im0] if isinstance(im0, np.ndarray) else im0
    for i, d in enumerate(x):  # per image
        if d is not None and len(d):
            d = d.clone()

            # Reshape and pad cutouts
            b = xyxy2xywh(d[:, :4])  # boxes
            b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # rectangle to square
            b[:, 2:] = b[:, 2:] * 1.3 + 30  # pad
            d[:, :4] = xywh2xyxy(b).long()

            # Rescale boxes from img_size to im0 size
            scale_coords(img.shape[2:], d[:, :4], im0[i].shape)

            # Classes
            pred_cls1 = d[:, 5].long()
            ims = []
            for j, a in enumerate(d):  # per item
                cutout = im0[i][int(a[1]) : int(a[3]), int(a[0]) : int(a[2])]
                im = cv2.resize(cutout, (224, 224))  # BGR
                # cv2.imwrite(&#39;test%i.jpg&#39; % j, cutout)

                im = im[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
                im = np.ascontiguousarray(im, dtype=np.float32)  # uint8 to float32
                im /= 255.0  # 0 - 255 to 0.0 - 1.0
                ims.append(im)

            pred_cls2 = model(torch.Tensor(ims).to(d.device)).argmax(
                1
            )  # classifier prediction
            x[i] = x[i][pred_cls1 == pred_cls2]  # retain matching class detections

    return x


def save_one_box(
    xyxy, im, file=&#34;image.jpg&#34;, gain=1.02, pad=10, square=False, BGR=False
):
    # Save an image crop as {file} with crop size multiplied by {gain} and padded by {pad} pixels
    xyxy = torch.tensor(xyxy).view(-1, 4)
    b = xyxy2xywh(xyxy)  # boxes
    if square:
        b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # attempt rectangle to square
    b[:, 2:] = b[:, 2:] * gain + pad  # box wh * gain + pad
    xyxy = xywh2xyxy(b).long()
    clip_coords(xyxy, im.shape)
    crop = im[int(xyxy[0, 1]) : int(xyxy[0, 3]), int(xyxy[0, 0]) : int(xyxy[0, 2])]
    cv2.imwrite(
        str(increment_path(file, mkdir=True).with_suffix(&#34;.jpg&#34;)),
        crop if BGR else crop[..., ::-1],
    )


def increment_path(path, exist_ok=False, sep=&#34;&#34;, mkdir=False):
    # Increment file or directory path, i.e. runs/exp --&gt; runs/exp{sep}2, runs/exp{sep}3, ... etc.
    path = Path(path)  # os-agnostic
    if path.exists() and not exist_ok:
        suffix = path.suffix
        path = path.with_suffix(&#34;&#34;)
        dirs = glob.glob(f&#34;{path}{sep}*&#34;)  # similar paths
        matches = [re.search(rf&#34;%s{sep}(\d+)&#34; % path.stem, d) for d in dirs]
        i = [int(m.groups()[0]) for m in matches if m]  # indices
        n = max(i) + 1 if i else 2  # increment number
        path = Path(f&#34;{path}{sep}{n}{suffix}&#34;)  # update path
    dir = path if path.suffix == &#34;&#34; else path.parent  # directory
    if not dir.exists() and mkdir:
        dir.mkdir(parents=True, exist_ok=True)  # make directory
    return path


def resize_aspectratio(image, width=None, height=None, inter=cv2.INTER_AREA):
    dim = None
    (h, w) = image.shape[:2]

    if width is None and height is None:
        return image
    if width is None:
        r = height / float(h)
        dim = (int(w * r), height)
    else:
        r = width / float(w)
        dim = (width, int(h * r))

    return cv2.resize(image, dim, interpolation=inter)


def export_onnx(
    model, onnx_path, input_tensor, dynamic_axes: bool = True, simplify: bool = True
):
    &#34;&#34;&#34;
    :param model: PyTorch model
    :param onnx_path: target location for new onnx model
    :param input: tensor with input data size
    &#34;&#34;&#34;
    if os.path.isfile(onnx_path):
        l.info(f&#34;Found a corresponding ONNX model at {onnx_path}&#34;)
        return True

    try:
        torch.onnx.export(
            model,
            input_tensor,
            onnx_path,
            input_names=[&#34;input&#34;],
            output_names=[&#34;output&#34;],
            opset_version=11,
            operator_export_type=torch.onnx.OperatorExportTypes.ONNX,
            training=torch.onnx.TrainingMode.EVAL,
            do_constant_folding=False,
            dynamic_axes={
                &#34;input&#34;: {0: &#34;batch&#34;, 2: &#34;height&#34;, 3: &#34;width&#34;},  # size(1,3,640,640)
                &#34;output&#34;: {0: &#34;batch&#34;, 2: &#34;y&#34;, 3: &#34;x&#34;},
            }
            if dynamic_axes
            else None,
            verbose=False,
        )

        # Checks
        model_onnx = onnx.load(onnx_path)  # load onnx model
        onnx.checker.check_model(model_onnx)  # check onnx model

        # Simplify
        if simplify:
            try:
                check_requirements([&#34;onnx-simplifier&#34;])
                import onnxsim

                l.info(f&#34;Simplifying with onnx-simplifier {onnxsim.__version__}...&#34;)
                model_onnx, check = onnxsim.simplify(
                    model_onnx,
                    dynamic_input_shape=dynamic_axes,
                    input_shapes={&#34;input&#34;: list(input_tensor.shape)}
                    if dynamic_axes
                    else None,
                )
                assert check, &#34;assert check failed&#34;
                onnx.save(model_onnx, onnx_path)
            except Exception as e:
                l.info(f&#34;Simplifier failure: {e}&#34;)
                return

        l.info(f&#34;Export success, saved as {onnx_path} ({file_size(onnx_path):.1f} MB)&#34;)
        return True
    except Exception as e:
        l.critical(f&#34;Export failure: {e}&#34;)
        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pancake.utils.general.apply_classifier"><code class="name flex">
<span>def <span class="ident">apply_classifier</span></span>(<span>x, model, img, im0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_classifier(x, model, img, im0):
    # Apply a second stage classifier to yolo outputs
    im0 = [im0] if isinstance(im0, np.ndarray) else im0
    for i, d in enumerate(x):  # per image
        if d is not None and len(d):
            d = d.clone()

            # Reshape and pad cutouts
            b = xyxy2xywh(d[:, :4])  # boxes
            b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # rectangle to square
            b[:, 2:] = b[:, 2:] * 1.3 + 30  # pad
            d[:, :4] = xywh2xyxy(b).long()

            # Rescale boxes from img_size to im0 size
            scale_coords(img.shape[2:], d[:, :4], im0[i].shape)

            # Classes
            pred_cls1 = d[:, 5].long()
            ims = []
            for j, a in enumerate(d):  # per item
                cutout = im0[i][int(a[1]) : int(a[3]), int(a[0]) : int(a[2])]
                im = cv2.resize(cutout, (224, 224))  # BGR
                # cv2.imwrite(&#39;test%i.jpg&#39; % j, cutout)

                im = im[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
                im = np.ascontiguousarray(im, dtype=np.float32)  # uint8 to float32
                im /= 255.0  # 0 - 255 to 0.0 - 1.0
                ims.append(im)

            pred_cls2 = model(torch.Tensor(ims).to(d.device)).argmax(
                1
            )  # classifier prediction
            x[i] = x[i][pred_cls1 == pred_cls2]  # retain matching class detections

    return x</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.bbox_iou"><code class="name flex">
<span>def <span class="ident">bbox_iou</span></span>(<span>box1, box2, x1y1x2y2=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-07)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox_iou(box1, box2, x1y1x2y2=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):
    # Returns the IoU of box1 to box2. box1 is 4, box2 is nx4
    box2 = box2.T

    # Get the coordinates of bounding boxes
    if x1y1x2y2:  # x1, y1, x2, y2 = box1
        b1_x1, b1_y1, b1_x2, b1_y2 = box1[0], box1[1], box1[2], box1[3]
        b2_x1, b2_y1, b2_x2, b2_y2 = box2[0], box2[1], box2[2], box2[3]
    else:  # transform from xywh to xyxy
        b1_x1, b1_x2 = box1[0] - box1[2] / 2, box1[0] + box1[2] / 2
        b1_y1, b1_y2 = box1[1] - box1[3] / 2, box1[1] + box1[3] / 2
        b2_x1, b2_x2 = box2[0] - box2[2] / 2, box2[0] + box2[2] / 2
        b2_y1, b2_y2 = box2[1] - box2[3] / 2, box2[1] + box2[3] / 2

    # Intersection area
    inter = (torch.min(b1_x2, b2_x2) - torch.max(b1_x1, b2_x1)).clamp(0) * (
        torch.min(b1_y2, b2_y2) - torch.max(b1_y1, b2_y1)
    ).clamp(0)

    # Union Area
    w1, h1 = b1_x2 - b1_x1, b1_y2 - b1_y1 + eps
    w2, h2 = b2_x2 - b2_x1, b2_y2 - b2_y1 + eps
    union = w1 * h1 + w2 * h2 - inter + eps

    iou = inter / union
    if GIoU or DIoU or CIoU:
        cw = torch.max(b1_x2, b2_x2) - torch.min(
            b1_x1, b2_x1
        )  # convex (smallest enclosing box) width
        ch = torch.max(b1_y2, b2_y2) - torch.min(b1_y1, b2_y1)  # convex height
        if CIoU or DIoU:  # Distance or Complete IoU https://arxiv.org/abs/1911.08287v1
            c2 = cw ** 2 + ch ** 2 + eps  # convex diagonal squared
            rho2 = (
                (b2_x1 + b2_x2 - b1_x1 - b1_x2) ** 2
                + (b2_y1 + b2_y2 - b1_y1 - b1_y2) ** 2
            ) / 4  # center distance squared
            if DIoU:
                return iou - rho2 / c2  # DIoU
            elif (
                CIoU
            ):  # https://github.com/Zzh-tju/DIoU-SSD-pytorch/blob/master/utils/box/box_utils.py#L47
                v = (4 / math.pi ** 2) * torch.pow(
                    torch.atan(w2 / h2) - torch.atan(w1 / h1), 2
                )
                with torch.no_grad():
                    alpha = v / (v - iou + (1 + eps))
                return iou - (rho2 / c2 + v * alpha)  # CIoU
        else:  # GIoU https://arxiv.org/pdf/1902.09630.pdf
            c_area = cw * ch + eps  # convex area
            return iou - (c_area - union) / c_area  # GIoU
    else:
        return iou  # IoU</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.box_iou"><code class="name flex">
<span>def <span class="ident">box_iou</span></span>(<span>box1, box2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return intersection-over-union (Jaccard index) of boxes.
Both sets of boxes are expected to be in (x1, y1, x2, y2) format.</p>
<h2 id="arguments">Arguments</h2>
<p>box1 (Tensor[N, 4])
box2 (Tensor[M, 4])</p>
<h2 id="returns">Returns</h2>
<p>iou (Tensor[N, M]): the NxM matrix containing the pairwise
IoU values for every element in boxes1 and boxes2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def box_iou(box1, box2):
    # https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py
    &#34;&#34;&#34;
    Return intersection-over-union (Jaccard index) of boxes.
    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
    Arguments:
        box1 (Tensor[N, 4])
        box2 (Tensor[M, 4])
    Returns:
        iou (Tensor[N, M]): the NxM matrix containing the pairwise
            IoU values for every element in boxes1 and boxes2
    &#34;&#34;&#34;

    def box_area(box):
        # box = 4xn
        return (box[2] - box[0]) * (box[3] - box[1])

    area1 = box_area(box1.T)
    area2 = box_area(box2.T)

    # inter(N,M) = (rb(N,M,2) - lt(N,M,2)).clamp(0).prod(2)
    inter = (
        (
            torch.min(box1[:, None, 2:], box2[:, 2:])
            - torch.max(box1[:, None, :2], box2[:, :2])
        )
        .clamp(0)
        .prod(2)
    )
    return inter / (
        area1[:, None] + area2 - inter
    )  # iou = inter / (area1 + area2 - inter)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_dataset"><code class="name flex">
<span>def <span class="ident">check_dataset</span></span>(<span>dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_dataset(dict):
    # Download dataset if not found locally
    val, s = dict.get(&#34;val&#34;), dict.get(&#34;download&#34;)
    if val and len(val):
        val = [
            Path(x).resolve() for x in (val if isinstance(val, list) else [val])
        ]  # val path
        if not all(x.exists() for x in val):
            print(
                &#34;\nWARNING: Dataset not found, nonexistent paths: %s&#34;
                % [str(x) for x in val if not x.exists()]
            )
            if s and len(s):  # download script
                if s.startswith(&#34;http&#34;) and s.endswith(&#34;.zip&#34;):  # URL
                    f = Path(s).name  # filename
                    print(f&#34;Downloading {s} ...&#34;)
                    torch.hub.download_url_to_file(s, f)
                    r = os.system(f&#34;unzip -q {f} -d ../ &amp;&amp; rm {f}&#34;)  # unzip
                elif s.startswith(&#34;bash &#34;):  # bash script
                    print(f&#34;Running {s} ...&#34;)
                    r = os.system(s)
                else:  # python script
                    r = exec(s)  # return None
                print(
                    &#34;Dataset autodownload %s\n&#34;
                    % (&#34;success&#34; if r in (0, None) else &#34;failure&#34;)
                )  # print result
            else:
                raise Exception(&#34;Dataset not found.&#34;)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_file"><code class="name flex">
<span>def <span class="ident">check_file</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_file(file):
    # Search for file if not found
    if Path(file).is_file() or file == &#34;&#34;:
        return file
    else:
        files = glob.glob(&#34;./**/&#34; + file, recursive=True)  # find file
        assert len(files), f&#34;File Not Found: {file}&#34;  # assert file was found
        assert (
            len(files) == 1
        ), f&#34;Multiple files match &#39;{file}&#39;, specify exact path: {files}&#34;  # assert unique
        return files[0]  # return file</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_git_status"><code class="name flex">
<span>def <span class="ident">check_git_status</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_git_status():
    # Recommend &#39;git pull&#39; if code is out of date
    l.debug(colorstr(&#34;github: &#34;))
    try:
        assert Path(&#34;.git&#34;).exists(), &#34;skipping check (not a git repository)&#34;
        assert not is_docker(), &#34;skipping check (Docker image)&#34;
        assert check_online(), &#34;skipping check (offline)&#34;

        cmd = &#34;git fetch &amp;&amp; git config --get remote.origin.url&#34;
        url = (
            subprocess.check_output(cmd, shell=True).decode().strip().rstrip(&#34;.git&#34;)
        )  # github repo url
        branch = (
            subprocess.check_output(&#34;git rev-parse --abbrev-ref HEAD&#34;, shell=True)
            .decode()
            .strip()
        )  # checked out
        n = int(
            subprocess.check_output(
                f&#34;git rev-list {branch}..origin/master --count&#34;, shell=True
            )
        )  # commits behind
        if n &gt; 0:
            s = (
                f&#34;⚠️ WARNING: code is out of date by {n} commit{&#39;s&#39; * (n &gt; 1)}. &#34;
                f&#34;Use &#39;git pull&#39; to update or &#39;git clone {url}&#39; to download latest.&#34;
            )
        else:
            s = f&#34;up to date with {url} ✅&#34;
        l.debug(emojis(s))  # emoji-safe
    except Exception as e:
        l.debug(e)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_img_size"><code class="name flex">
<span>def <span class="ident">check_img_size</span></span>(<span>img_size, s=32)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_img_size(img_size, s=32):
    # Verify img_size is a multiple of stride s
    new_size = make_divisible(img_size, int(s))  # ceil gs-multiple
    if new_size != img_size:
        print(
            &#34;WARNING: --img-size %g must be multiple of max stride %g, updating to %g&#34;
            % (img_size, s, new_size)
        )
    return new_size</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_imshow"><code class="name flex">
<span>def <span class="ident">check_imshow</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_imshow():
    # Check if environment supports image displays
    try:
        assert not is_docker(), &#34;cv2.imshow() is disabled in Docker environments&#34;
        assert not is_colab(), &#34;cv2.imshow() is disabled in Google Colab environments&#34;
        cv2.imshow(&#34;test&#34;, np.zeros((1, 1, 3)))
        cv2.waitKey(1)
        cv2.destroyAllWindows()
        cv2.waitKey(1)
        return True
    except Exception as e:
        print(
            f&#34;WARNING: Environment does not support cv2.imshow() or PIL Image.show() image displays\n{e}&#34;
        )
        return False</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_online"><code class="name flex">
<span>def <span class="ident">check_online</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_online():
    # Check internet connectivity
    import socket

    try:
        socket.create_connection((&#34;1.1.1.1&#34;, 443), 5)  # check host accesability
        return True
    except OSError:
        return False</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.check_requirements"><code class="name flex">
<span>def <span class="ident">check_requirements</span></span>(<span>requirements='requirements.txt', exclude=())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_requirements(requirements=&#34;requirements.txt&#34;, exclude=()):
    # Check installed dependencies meet requirements (pass *.txt file or list of packages)
    import pkg_resources as pkg

    prefix = colorstr(&#34;red&#34;, &#34;bold&#34;, &#34;requirements:&#34;)
    if isinstance(requirements, (str, Path)):  # requirements.txt file
        file = Path(requirements)
        if not file.exists():
            print(f&#34;{prefix} {file.resolve()} not found, check failed.&#34;)
            return
        requirements = [
            f&#34;{x.name}{x.specifier}&#34;
            for x in pkg.parse_requirements(file.open())
            if x.name not in exclude
        ]
    else:  # list or tuple of packages
        requirements = [x for x in requirements if x not in exclude]

    n = 0  # number of packages updates
    for r in requirements:
        try:
            pkg.require(r)
        except Exception as e:  # DistributionNotFound or VersionConflict if requirements not met
            n += 1
            print(
                f&#34;{prefix} {r} not found and is required by pancake, attempting auto-update...&#34;
            )
            print(subprocess.check_output(f&#34;pip install &#39;{r}&#39;&#34;, shell=True).decode())

    if n:  # if packages updated
        source = file.resolve() if &#34;file&#34; in locals() else requirements
        s = (
            f&#34;{prefix} {n} package{&#39;s&#39; * (n &gt; 1)} updated per {source}\n&#34;
            f&#34;{prefix} ⚠️ {colorstr(&#39;bold&#39;, &#39;Restart runtime or rerun command for updates to take effect&#39;)}\n&#34;
        )
        print(emojis(s))  # emoji-safe</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.clean_str"><code class="name flex">
<span>def <span class="ident">clean_str</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_str(s):
    # Cleans a string by replacing special characters with underscore _
    return re.sub(pattern=&#34;[|@#!¡·$€%&amp;()=?¿^*;:,¨´&gt;&lt;+]&#34;, repl=&#34;_&#34;, string=s)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.clip_coords"><code class="name flex">
<span>def <span class="ident">clip_coords</span></span>(<span>boxes, img_shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clip_coords(boxes, img_shape):
    # Clip bounding xyxy bounding boxes to image shape (height, width)
    boxes[:, 0].clamp_(0, img_shape[1])  # x1
    boxes[:, 1].clamp_(0, img_shape[0])  # y1
    boxes[:, 2].clamp_(0, img_shape[1])  # x2
    boxes[:, 3].clamp_(0, img_shape[0])  # y2</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.coco80_to_coco91_class"><code class="name flex">
<span>def <span class="ident">coco80_to_coco91_class</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coco80_to_coco91_class():  # converts 80-index (val2014) to 91-index (paper)
    # https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/
    # a = np.loadtxt(&#39;data/coco.names&#39;, dtype=&#39;str&#39;, delimiter=&#39;\n&#39;)
    # b = np.loadtxt(&#39;data/coco_paper.names&#39;, dtype=&#39;str&#39;, delimiter=&#39;\n&#39;)
    # x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco
    # x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet
    x = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        27,
        28,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        67,
        70,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
    ]
    return x</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.colorstr"><code class="name flex">
<span>def <span class="ident">colorstr</span></span>(<span>*input)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def colorstr(*input):
    # Colors a string https://en.wikipedia.org/wiki/ANSI_escape_code, i.e.  colorstr(&#39;blue&#39;, &#39;hello world&#39;)
    *args, string = (
        input if len(input) &gt; 1 else (&#34;blue&#34;, &#34;bold&#34;, input[0])
    )  # color arguments, string
    colors = {
        &#34;black&#34;: &#34;\033[30m&#34;,  # basic colors
        &#34;red&#34;: &#34;\033[31m&#34;,
        &#34;green&#34;: &#34;\033[32m&#34;,
        &#34;yellow&#34;: &#34;\033[33m&#34;,
        &#34;blue&#34;: &#34;\033[34m&#34;,
        &#34;magenta&#34;: &#34;\033[35m&#34;,
        &#34;cyan&#34;: &#34;\033[36m&#34;,
        &#34;white&#34;: &#34;\033[37m&#34;,
        &#34;bright_black&#34;: &#34;\033[90m&#34;,  # bright colors
        &#34;bright_red&#34;: &#34;\033[91m&#34;,
        &#34;bright_green&#34;: &#34;\033[92m&#34;,
        &#34;bright_yellow&#34;: &#34;\033[93m&#34;,
        &#34;bright_blue&#34;: &#34;\033[94m&#34;,
        &#34;bright_magenta&#34;: &#34;\033[95m&#34;,
        &#34;bright_cyan&#34;: &#34;\033[96m&#34;,
        &#34;bright_white&#34;: &#34;\033[97m&#34;,
        &#34;end&#34;: &#34;\033[0m&#34;,  # misc
        &#34;bold&#34;: &#34;\033[1m&#34;,
        &#34;underline&#34;: &#34;\033[4m&#34;,
    }
    return &#34;&#34;.join(colors[x] for x in args) + f&#34;{string}&#34; + colors[&#34;end&#34;]</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>url, dir='.', unzip=True, delete=True, curl=False, threads=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(url, dir=&#34;.&#34;, unzip=True, delete=True, curl=False, threads=1):
    # Multi-threaded file download and unzip function
    def download_one(url, dir):
        # Download 1 file
        f = dir / Path(url).name  # filename
        if not f.exists():
            print(f&#34;Downloading {url} to {f}...&#34;)
            if curl:
                os.system(
                    f&#34;curl -L &#39;{url}&#39; -o &#39;{f}&#39; --retry 9 -C -&#34;
                )  # curl download, retry and resume on fail
            else:
                torch.hub.download_url_to_file(url, f, progress=True)  # torch download
        if unzip and f.suffix in (&#34;.zip&#34;, &#34;.gz&#34;):
            print(f&#34;Unzipping {f}...&#34;)
            if f.suffix == &#34;.zip&#34;:
                s = f&#34;unzip -qo {f} -d {dir} &amp;&amp; rm {f}&#34;  # unzip -quiet -overwrite
            elif f.suffix == &#34;.gz&#34;:
                s = f&#34;tar xfz {f} --directory {f.parent}&#34;  # unzip
            if delete:  # delete zip file after unzip
                s += f&#34; &amp;&amp; rm {f}&#34;
            os.system(s)

    dir = Path(dir)
    dir.mkdir(parents=True, exist_ok=True)  # make directory
    if threads &gt; 1:
        pool = ThreadPool(threads)
        pool.imap(lambda x: download_one(*x), zip(url, repeat(dir)))  # multi-threaded
        pool.close()
        pool.join()
    else:
        for u in tuple(url) if isinstance(url, str) else url:
            download_one(u, dir)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.emojis"><code class="name flex">
<span>def <span class="ident">emojis</span></span>(<span>str='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emojis(str=&#34;&#34;):
    # Return platform-dependent emoji-safe version of string
    return (
        str.encode().decode(&#34;ascii&#34;, &#34;ignore&#34;)
        if platform.system() == &#34;Windows&#34;
        else str
    )</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.export_onnx"><code class="name flex">
<span>def <span class="ident">export_onnx</span></span>(<span>model, onnx_path, input_tensor, dynamic_axes: bool = True, simplify: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>:param model: PyTorch model
:param onnx_path: target location for new onnx model
:param input: tensor with input data size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_onnx(
    model, onnx_path, input_tensor, dynamic_axes: bool = True, simplify: bool = True
):
    &#34;&#34;&#34;
    :param model: PyTorch model
    :param onnx_path: target location for new onnx model
    :param input: tensor with input data size
    &#34;&#34;&#34;
    if os.path.isfile(onnx_path):
        l.info(f&#34;Found a corresponding ONNX model at {onnx_path}&#34;)
        return True

    try:
        torch.onnx.export(
            model,
            input_tensor,
            onnx_path,
            input_names=[&#34;input&#34;],
            output_names=[&#34;output&#34;],
            opset_version=11,
            operator_export_type=torch.onnx.OperatorExportTypes.ONNX,
            training=torch.onnx.TrainingMode.EVAL,
            do_constant_folding=False,
            dynamic_axes={
                &#34;input&#34;: {0: &#34;batch&#34;, 2: &#34;height&#34;, 3: &#34;width&#34;},  # size(1,3,640,640)
                &#34;output&#34;: {0: &#34;batch&#34;, 2: &#34;y&#34;, 3: &#34;x&#34;},
            }
            if dynamic_axes
            else None,
            verbose=False,
        )

        # Checks
        model_onnx = onnx.load(onnx_path)  # load onnx model
        onnx.checker.check_model(model_onnx)  # check onnx model

        # Simplify
        if simplify:
            try:
                check_requirements([&#34;onnx-simplifier&#34;])
                import onnxsim

                l.info(f&#34;Simplifying with onnx-simplifier {onnxsim.__version__}...&#34;)
                model_onnx, check = onnxsim.simplify(
                    model_onnx,
                    dynamic_input_shape=dynamic_axes,
                    input_shapes={&#34;input&#34;: list(input_tensor.shape)}
                    if dynamic_axes
                    else None,
                )
                assert check, &#34;assert check failed&#34;
                onnx.save(model_onnx, onnx_path)
            except Exception as e:
                l.info(f&#34;Simplifier failure: {e}&#34;)
                return

        l.info(f&#34;Export success, saved as {onnx_path} ({file_size(onnx_path):.1f} MB)&#34;)
        return True
    except Exception as e:
        l.critical(f&#34;Export failure: {e}&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.file_size"><code class="name flex">
<span>def <span class="ident">file_size</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_size(file):
    # Return file size in MB
    return Path(file).stat().st_size / 1e6</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.get_latest_run"><code class="name flex">
<span>def <span class="ident">get_latest_run</span></span>(<span>search_dir='.')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latest_run(search_dir=&#34;.&#34;):
    # Return path to most recent &#39;last.pt&#39; in /runs (i.e. to --resume from)
    last_list = glob.glob(f&#34;{search_dir}/**/last*.pt&#34;, recursive=True)
    return max(last_list, key=os.path.getctime) if last_list else &#34;&#34;</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.increment_path"><code class="name flex">
<span>def <span class="ident">increment_path</span></span>(<span>path, exist_ok=False, sep='', mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_path(path, exist_ok=False, sep=&#34;&#34;, mkdir=False):
    # Increment file or directory path, i.e. runs/exp --&gt; runs/exp{sep}2, runs/exp{sep}3, ... etc.
    path = Path(path)  # os-agnostic
    if path.exists() and not exist_ok:
        suffix = path.suffix
        path = path.with_suffix(&#34;&#34;)
        dirs = glob.glob(f&#34;{path}{sep}*&#34;)  # similar paths
        matches = [re.search(rf&#34;%s{sep}(\d+)&#34; % path.stem, d) for d in dirs]
        i = [int(m.groups()[0]) for m in matches if m]  # indices
        n = max(i) + 1 if i else 2  # increment number
        path = Path(f&#34;{path}{sep}{n}{suffix}&#34;)  # update path
    dir = path if path.suffix == &#34;&#34; else path.parent  # directory
    if not dir.exists() and mkdir:
        dir.mkdir(parents=True, exist_ok=True)  # make directory
    return path</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.init_seeds"><code class="name flex">
<span>def <span class="ident">init_seeds</span></span>(<span>seed=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_seeds(seed=0):
    # Initialize random number generator (RNG) seeds
    random.seed(seed)
    np.random.seed(seed)
    init_torch_seeds(seed)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.is_colab"><code class="name flex">
<span>def <span class="ident">is_colab</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_colab():
    # Is environment a Google Colab instance
    try:
        import google.colab

        return True
    except Exception as e:
        return False</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.is_docker"><code class="name flex">
<span>def <span class="ident">is_docker</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_docker():
    # Is environment a Docker container
    return Path(&#34;/workspace&#34;).exists()  # or Path(&#39;/.dockerenv&#39;).exists()</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.labels_to_class_weights"><code class="name flex">
<span>def <span class="ident">labels_to_class_weights</span></span>(<span>labels, nc=80)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def labels_to_class_weights(labels, nc=80):
    # Get class weights (inverse frequency) from training labels
    if labels[0] is None:  # no labels loaded
        return torch.Tensor()

    labels = np.concatenate(labels, 0)  # labels.shape = (866643, 5) for COCO
    classes = labels[:, 0].astype(np.int)  # labels = [class xywh]
    weights = np.bincount(classes, minlength=nc)  # occurrences per class

    # Prepend gridpoint count (for uCE training)
    # gpi = ((320 / 32 * np.array([1, 2, 4])) ** 2 * 3).sum()  # gridpoints per image
    # weights = np.hstack([gpi * len(labels)  - weights.sum() * 9, weights * 9]) ** 0.5  # prepend gridpoints to start

    weights[weights == 0] = 1  # replace empty bins with 1
    weights = 1 / weights  # number of targets per class
    weights /= weights.sum()  # normalize
    return torch.from_numpy(weights)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.labels_to_image_weights"><code class="name flex">
<span>def <span class="ident">labels_to_image_weights</span></span>(<span>labels, nc=80, class_weights=array([
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1]))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def labels_to_image_weights(labels, nc=80, class_weights=np.ones(80)):
    # Produces image weights based on class_weights and image contents
    class_counts = np.array(
        [np.bincount(x[:, 0].astype(np.int), minlength=nc) for x in labels]
    )
    image_weights = (class_weights.reshape(1, nc) * class_counts).sum(1)
    # index = random.choices(range(n), weights=image_weights, k=1)  # weight image sample
    return image_weights</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.make_divisible"><code class="name flex">
<span>def <span class="ident">make_divisible</span></span>(<span>x, divisor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_divisible(x, divisor):
    # Returns x evenly divisible by divisor
    return math.ceil(x / divisor) * divisor</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.non_max_suppression"><code class="name flex">
<span>def <span class="ident">non_max_suppression</span></span>(<span>prediction, conf_thres=0.25, iou_thres=0.45, classes=None, agnostic=False, multi_label=False, max_det=300, labels=())</span>
</code></dt>
<dd>
<div class="desc"><p>Runs Non-Maximum Suppression (NMS) on inference results</p>
<h2 id="returns">Returns</h2>
<p>list of detections, on (n,6) tensor per image [xyxy, conf, cls]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def non_max_suppression(
    prediction,
    conf_thres=0.25,
    iou_thres=0.45,
    classes=None,
    agnostic=False,
    multi_label=False,
    max_det=300,
    labels=(),
):
    &#34;&#34;&#34;Runs Non-Maximum Suppression (NMS) on inference results

    Returns:
         list of detections, on (n,6) tensor per image [xyxy, conf, cls]
    &#34;&#34;&#34;

    nc = prediction.shape[2] - 5  # number of classes
    xc = prediction[..., 4] &gt; conf_thres  # candidates

    # Checks
    assert (
        0 &lt;= conf_thres &lt;= 1
    ), f&#34;Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0&#34;
    assert (
        0 &lt;= iou_thres &lt;= 1
    ), f&#34;Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0&#34;

    # Settings
    min_wh, max_wh = 2, 4096  # (pixels) minimum and maximum box width and height
    max_nms = 30000  # maximum number of boxes into torchvision.ops.nms()
    time_limit = 10.0  # seconds to quit after
    redundant = True  # require redundant detections
    multi_label &amp;= nc &gt; 1  # multiple labels per box (adds 0.5ms/img)
    merge = False  # use merge-NMS

    t = time.time()
    output = [torch.zeros((0, 6), device=prediction.device)] * prediction.shape[0]
    for xi, x in enumerate(prediction):  # image index, image inference
        # Apply constraints
        # x[((x[..., 2:4] &lt; min_wh) | (x[..., 2:4] &gt; max_wh)).any(1), 4] = 0  # width-height
        x = x[xc[xi]]  # confidence

        # Cat apriori labels if autolabelling
        if labels and len(labels[xi]):
            l = labels[xi]
            v = torch.zeros((len(l), nc + 5), device=x.device)
            v[:, :4] = l[:, 1:5]  # box
            v[:, 4] = 1.0  # conf
            v[range(len(l)), l[:, 0].long() + 5] = 1.0  # cls
            x = torch.cat((x, v), 0)

        # If none remain process next image
        if not x.shape[0]:
            continue

        # Compute conf
        x[:, 5:] *= x[:, 4:5]  # conf = obj_conf * cls_conf

        # Box (center x, center y, width, height) to (x1, y1, x2, y2)
        box = xywh2xyxy(x[:, :4])

        # Detections matrix nx6 (xyxy, conf, cls)
        if multi_label:
            i, j = (x[:, 5:] &gt; conf_thres).nonzero(as_tuple=False).T
            x = torch.cat((box[i], x[i, j + 5, None], j[:, None].float()), 1)
        else:  # best class only
            conf, j = x[:, 5:].max(1, keepdim=True)
            x = torch.cat((box, conf, j.float()), 1)[conf.view(-1) &gt; conf_thres]

        # Filter by class
        if classes is not None:
            x = x[(x[:, 5:6] == torch.tensor(classes, device=x.device)).any(1)]

        # Apply finite constraint
        # if not torch.isfinite(x).all():
        #     x = x[torch.isfinite(x).all(1)]

        # Check shape
        n = x.shape[0]  # number of boxes
        if not n:  # no boxes
            continue
        elif n &gt; max_nms:  # excess boxes
            x = x[x[:, 4].argsort(descending=True)[:max_nms]]  # sort by confidence

        # Batched NMS
        c = x[:, 5:6] * (0 if agnostic else max_wh)  # classes
        boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores
        i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS
        if i.shape[0] &gt; max_det:  # limit detections
            i = i[:max_det]
        if merge and (1 &lt; n &lt; 3e3):  # Merge NMS (boxes merged using weighted mean)
            # update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)
            iou = box_iou(boxes[i], boxes) &gt; iou_thres  # iou matrix
            weights = iou * scores[None]  # box weights
            x[i, :4] = torch.mm(weights, x[:, :4]).float() / weights.sum(
                1, keepdim=True
            )  # merged boxes
            if redundant:
                i = i[iou.sum(1) &gt; 1]  # require redundancy

        output[xi] = x[i]
        if (time.time() - t) &gt; time_limit:
            print(f&#34;WARNING: NMS time limit {time_limit}s exceeded&#34;)
            break  # time limit exceeded

    return output</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.one_cycle"><code class="name flex">
<span>def <span class="ident">one_cycle</span></span>(<span>y1=0.0, y2=1.0, steps=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_cycle(y1=0.0, y2=1.0, steps=100):
    # lambda function for sinusoidal ramp from y1 to y2
    return lambda x: ((1 - math.cos(x * math.pi / steps)) / 2) * (y2 - y1) + y1</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.print_mutation"><code class="name flex">
<span>def <span class="ident">print_mutation</span></span>(<span>hyp, results, yaml_file='hyp_evolved.yaml', bucket='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_mutation(hyp, results, yaml_file=&#34;hyp_evolved.yaml&#34;, bucket=&#34;&#34;):
    # Print mutation results to evolve.txt (for use with train.py --evolve)
    a = &#34;%10s&#34; * len(hyp) % tuple(hyp.keys())  # hyperparam keys
    b = &#34;%10.3g&#34; * len(hyp) % tuple(hyp.values())  # hyperparam values
    c = (
        &#34;%10.4g&#34; * len(results) % results
    )  # results (P, R, mAP@0.5, mAP@0.5:0.95, val_losses x 3)
    print(&#34;\n%s\n%s\nEvolved fitness: %s\n&#34; % (a, b, c))

    if bucket:
        url = &#34;gs://%s/evolve.txt&#34; % bucket
        if gsutil_getsize(url) &gt; (
            os.path.getsize(&#34;evolve.txt&#34;) if os.path.exists(&#34;evolve.txt&#34;) else 0
        ):
            os.system(
                &#34;gsutil cp %s .&#34; % url
            )  # download evolve.txt if larger than local

    with open(&#34;evolve.txt&#34;, &#34;a&#34;) as f:  # append result
        f.write(c + b + &#34;\n&#34;)
    x = np.unique(np.loadtxt(&#34;evolve.txt&#34;, ndmin=2), axis=0)  # load unique rows
    x = x[np.argsort(-fitness(x))]  # sort
    np.savetxt(&#34;evolve.txt&#34;, x, &#34;%10.3g&#34;)  # save sort by fitness

    # Save yaml
    for i, k in enumerate(hyp.keys()):
        hyp[k] = float(x[0, i + 7])
    with open(yaml_file, &#34;w&#34;) as f:
        results = tuple(x[0, :7])
        c = (
            &#34;%10.4g&#34; * len(results) % results
        )  # results (P, R, mAP@0.5, mAP@0.5:0.95, val_losses x 3)
        f.write(
            &#34;# Hyperparameter Evolution Results\n# Generations: %g\n# Metrics: &#34;
            % len(x)
            + c
            + &#34;\n\n&#34;
        )
        yaml.safe_dump(hyp, f, sort_keys=False)

    if bucket:
        os.system(&#34;gsutil cp evolve.txt %s gs://%s&#34; % (yaml_file, bucket))  # upload</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.resample_segments"><code class="name flex">
<span>def <span class="ident">resample_segments</span></span>(<span>segments, n=1000)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resample_segments(segments, n=1000):
    # Up-sample an (n,2) segment
    for i, s in enumerate(segments):
        x = np.linspace(0, len(s) - 1, n)
        xp = np.arange(len(s))
        segments[i] = (
            np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)])
            .reshape(2, -1)
            .T
        )  # segment xy
    return segments</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.resize_aspectratio"><code class="name flex">
<span>def <span class="ident">resize_aspectratio</span></span>(<span>image, width=None, height=None, inter=3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_aspectratio(image, width=None, height=None, inter=cv2.INTER_AREA):
    dim = None
    (h, w) = image.shape[:2]

    if width is None and height is None:
        return image
    if width is None:
        r = height / float(h)
        dim = (int(w * r), height)
    else:
        r = width / float(w)
        dim = (width, int(h * r))

    return cv2.resize(image, dim, interpolation=inter)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.save_one_box"><code class="name flex">
<span>def <span class="ident">save_one_box</span></span>(<span>xyxy, im, file='image.jpg', gain=1.02, pad=10, square=False, BGR=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_one_box(
    xyxy, im, file=&#34;image.jpg&#34;, gain=1.02, pad=10, square=False, BGR=False
):
    # Save an image crop as {file} with crop size multiplied by {gain} and padded by {pad} pixels
    xyxy = torch.tensor(xyxy).view(-1, 4)
    b = xyxy2xywh(xyxy)  # boxes
    if square:
        b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # attempt rectangle to square
    b[:, 2:] = b[:, 2:] * gain + pad  # box wh * gain + pad
    xyxy = xywh2xyxy(b).long()
    clip_coords(xyxy, im.shape)
    crop = im[int(xyxy[0, 1]) : int(xyxy[0, 3]), int(xyxy[0, 0]) : int(xyxy[0, 2])]
    cv2.imwrite(
        str(increment_path(file, mkdir=True).with_suffix(&#34;.jpg&#34;)),
        crop if BGR else crop[..., ::-1],
    )</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.scale_coords"><code class="name flex">
<span>def <span class="ident">scale_coords</span></span>(<span>img1_shape, coords, img0_shape, ratio_pad=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None):
    # Rescale coords (xyxy) from img1_shape to img0_shape
    if ratio_pad is None:  # calculate from img0_shape
        gain = min(
            img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1]
        )  # gain  = old / new
        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (
            img1_shape[0] - img0_shape[0] * gain
        ) / 2  # wh padding
    else:
        gain = ratio_pad[0][0]
        pad = ratio_pad[1]

    coords[:, [0, 2]] -= pad[0]  # x padding
    coords[:, [1, 3]] -= pad[1]  # y padding
    coords[:, :4] /= gain
    clip_coords(coords, img0_shape)
    return coords</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.segment2box"><code class="name flex">
<span>def <span class="ident">segment2box</span></span>(<span>segment, width=640, height=640)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment2box(segment, width=640, height=640):
    # Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy)
    x, y = segment.T  # segment xy
    inside = (x &gt;= 0) &amp; (y &gt;= 0) &amp; (x &lt;= width) &amp; (y &lt;= height)
    x, y, = (
        x[inside],
        y[inside],
    )
    return (
        np.array([x.min(), y.min(), x.max(), y.max()]) if any(x) else np.zeros((1, 4))
    )  # xyxy</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.segments2boxes"><code class="name flex">
<span>def <span class="ident">segments2boxes</span></span>(<span>segments)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segments2boxes(segments):
    # Convert segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)
    boxes = []
    for s in segments:
        x, y = s.T  # segment xy
        boxes.append([x.min(), y.min(), x.max(), y.max()])  # cls, xyxy
    return xyxy2xywh(np.array(boxes))  # cls, xywh</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.set_logging"><code class="name flex">
<span>def <span class="ident">set_logging</span></span>(<span>rank=-1, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_logging(rank=-1, verbose=True):
    raise DeprecationWarning(&#34;Use pancake.logger instead!&#34;)
    # logging.basicConfig(
    # format=&#34;%(message)s&#34;,
    # level=logging.INFO if (verbose and rank in [-1, 0]) else logging.WARN,
    # )</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.strip_optimizer"><code class="name flex">
<span>def <span class="ident">strip_optimizer</span></span>(<span>f='best.pt', s='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_optimizer(
    f=&#34;best.pt&#34;, s=&#34;&#34;
):  # from utils.general import *; strip_optimizer()
    # Strip optimizer from &#39;f&#39; to finalize training, optionally save as &#39;s&#39;
    x = torch.load(f, map_location=torch.device(&#34;cpu&#34;))
    if x.get(&#34;ema&#34;):
        x[&#34;model&#34;] = x[&#34;ema&#34;]  # replace model with ema
    for k in &#34;optimizer&#34;, &#34;training_results&#34;, &#34;wandb_id&#34;, &#34;ema&#34;, &#34;updates&#34;:  # keys
        x[k] = None
    x[&#34;epoch&#34;] = -1
    x[&#34;model&#34;].half()  # to FP16
    for p in x[&#34;model&#34;].parameters():
        p.requires_grad = False
    torch.save(x, s or f)
    mb = os.path.getsize(s or f) / 1e6  # filesize
    print(
        f&#34;Optimizer stripped from {f},{(&#39; saved as %s,&#39; % s) if s else &#39;&#39;} {mb:.1f}MB&#34;
    )</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.wh_iou"><code class="name flex">
<span>def <span class="ident">wh_iou</span></span>(<span>wh1, wh2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wh_iou(wh1, wh2):
    # Returns the nxm IoU matrix. wh1 is nx2, wh2 is mx2
    wh1 = wh1[:, None]  # [N,1,2]
    wh2 = wh2[None]  # [1,M,2]
    inter = torch.min(wh1, wh2).prod(2)  # [N,M]
    return inter / (
        wh1.prod(2) + wh2.prod(2) - inter
    )  # iou = inter / (area1 + area2 - inter)</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.xyn2xy"><code class="name flex">
<span>def <span class="ident">xyn2xy</span></span>(<span>x, w=640, h=640, padw=0, padh=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyn2xy(x, w=640, h=640, padw=0, padh=0):
    # Convert normalized segments into pixel segments, shape (n,2)
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = w * x[:, 0] + padw  # top left x
    y[:, 1] = h * x[:, 1] + padh  # top left y
    return y</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.xywh2xyxy"><code class="name flex">
<span>def <span class="ident">xywh2xyxy</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xywh2xyxy(x):
    # Convert nx4 boxes from [x, y, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = x[:, 0] - x[:, 2] / 2  # top left x
    y[:, 1] = x[:, 1] - x[:, 3] / 2  # top left y
    y[:, 2] = x[:, 0] + x[:, 2] / 2  # bottom right x
    y[:, 3] = x[:, 1] + x[:, 3] / 2  # bottom right y
    return y</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.xywhn2xyxy"><code class="name flex">
<span>def <span class="ident">xywhn2xyxy</span></span>(<span>x, w=640, h=640, padw=0, padh=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):
    # Convert nx4 boxes from [x, y, w, h] normalized to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = w * (x[:, 0] - x[:, 2] / 2) + padw  # top left x
    y[:, 1] = h * (x[:, 1] - x[:, 3] / 2) + padh  # top left y
    y[:, 2] = w * (x[:, 0] + x[:, 2] / 2) + padw  # bottom right x
    y[:, 3] = h * (x[:, 1] + x[:, 3] / 2) + padh  # bottom right y
    return y</code></pre>
</details>
</dd>
<dt id="pancake.utils.general.xyxy2xywh"><code class="name flex">
<span>def <span class="ident">xyxy2xywh</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyxy2xywh(x):
    # Convert nx4 boxes from [x1, y1, x2, y2] to [x, y, w, h] where xy1=top-left, xy2=bottom-right
    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)
    y[:, 0] = (x[:, 0] + x[:, 2]) / 2  # x center
    y[:, 1] = (x[:, 1] + x[:, 3]) / 2  # y center
    y[:, 2] = x[:, 2] - x[:, 0]  # width
    y[:, 3] = x[:, 3] - x[:, 1]  # height
    return y</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pancake.utils" href="index.html">pancake.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pancake.utils.general.apply_classifier" href="#pancake.utils.general.apply_classifier">apply_classifier</a></code></li>
<li><code><a title="pancake.utils.general.bbox_iou" href="#pancake.utils.general.bbox_iou">bbox_iou</a></code></li>
<li><code><a title="pancake.utils.general.box_iou" href="#pancake.utils.general.box_iou">box_iou</a></code></li>
<li><code><a title="pancake.utils.general.check_dataset" href="#pancake.utils.general.check_dataset">check_dataset</a></code></li>
<li><code><a title="pancake.utils.general.check_file" href="#pancake.utils.general.check_file">check_file</a></code></li>
<li><code><a title="pancake.utils.general.check_git_status" href="#pancake.utils.general.check_git_status">check_git_status</a></code></li>
<li><code><a title="pancake.utils.general.check_img_size" href="#pancake.utils.general.check_img_size">check_img_size</a></code></li>
<li><code><a title="pancake.utils.general.check_imshow" href="#pancake.utils.general.check_imshow">check_imshow</a></code></li>
<li><code><a title="pancake.utils.general.check_online" href="#pancake.utils.general.check_online">check_online</a></code></li>
<li><code><a title="pancake.utils.general.check_requirements" href="#pancake.utils.general.check_requirements">check_requirements</a></code></li>
<li><code><a title="pancake.utils.general.clean_str" href="#pancake.utils.general.clean_str">clean_str</a></code></li>
<li><code><a title="pancake.utils.general.clip_coords" href="#pancake.utils.general.clip_coords">clip_coords</a></code></li>
<li><code><a title="pancake.utils.general.coco80_to_coco91_class" href="#pancake.utils.general.coco80_to_coco91_class">coco80_to_coco91_class</a></code></li>
<li><code><a title="pancake.utils.general.colorstr" href="#pancake.utils.general.colorstr">colorstr</a></code></li>
<li><code><a title="pancake.utils.general.download" href="#pancake.utils.general.download">download</a></code></li>
<li><code><a title="pancake.utils.general.emojis" href="#pancake.utils.general.emojis">emojis</a></code></li>
<li><code><a title="pancake.utils.general.export_onnx" href="#pancake.utils.general.export_onnx">export_onnx</a></code></li>
<li><code><a title="pancake.utils.general.file_size" href="#pancake.utils.general.file_size">file_size</a></code></li>
<li><code><a title="pancake.utils.general.get_latest_run" href="#pancake.utils.general.get_latest_run">get_latest_run</a></code></li>
<li><code><a title="pancake.utils.general.increment_path" href="#pancake.utils.general.increment_path">increment_path</a></code></li>
<li><code><a title="pancake.utils.general.init_seeds" href="#pancake.utils.general.init_seeds">init_seeds</a></code></li>
<li><code><a title="pancake.utils.general.is_colab" href="#pancake.utils.general.is_colab">is_colab</a></code></li>
<li><code><a title="pancake.utils.general.is_docker" href="#pancake.utils.general.is_docker">is_docker</a></code></li>
<li><code><a title="pancake.utils.general.labels_to_class_weights" href="#pancake.utils.general.labels_to_class_weights">labels_to_class_weights</a></code></li>
<li><code><a title="pancake.utils.general.labels_to_image_weights" href="#pancake.utils.general.labels_to_image_weights">labels_to_image_weights</a></code></li>
<li><code><a title="pancake.utils.general.make_divisible" href="#pancake.utils.general.make_divisible">make_divisible</a></code></li>
<li><code><a title="pancake.utils.general.non_max_suppression" href="#pancake.utils.general.non_max_suppression">non_max_suppression</a></code></li>
<li><code><a title="pancake.utils.general.one_cycle" href="#pancake.utils.general.one_cycle">one_cycle</a></code></li>
<li><code><a title="pancake.utils.general.print_mutation" href="#pancake.utils.general.print_mutation">print_mutation</a></code></li>
<li><code><a title="pancake.utils.general.resample_segments" href="#pancake.utils.general.resample_segments">resample_segments</a></code></li>
<li><code><a title="pancake.utils.general.resize_aspectratio" href="#pancake.utils.general.resize_aspectratio">resize_aspectratio</a></code></li>
<li><code><a title="pancake.utils.general.save_one_box" href="#pancake.utils.general.save_one_box">save_one_box</a></code></li>
<li><code><a title="pancake.utils.general.scale_coords" href="#pancake.utils.general.scale_coords">scale_coords</a></code></li>
<li><code><a title="pancake.utils.general.segment2box" href="#pancake.utils.general.segment2box">segment2box</a></code></li>
<li><code><a title="pancake.utils.general.segments2boxes" href="#pancake.utils.general.segments2boxes">segments2boxes</a></code></li>
<li><code><a title="pancake.utils.general.set_logging" href="#pancake.utils.general.set_logging">set_logging</a></code></li>
<li><code><a title="pancake.utils.general.strip_optimizer" href="#pancake.utils.general.strip_optimizer">strip_optimizer</a></code></li>
<li><code><a title="pancake.utils.general.wh_iou" href="#pancake.utils.general.wh_iou">wh_iou</a></code></li>
<li><code><a title="pancake.utils.general.xyn2xy" href="#pancake.utils.general.xyn2xy">xyn2xy</a></code></li>
<li><code><a title="pancake.utils.general.xywh2xyxy" href="#pancake.utils.general.xywh2xyxy">xywh2xyxy</a></code></li>
<li><code><a title="pancake.utils.general.xywhn2xyxy" href="#pancake.utils.general.xywhn2xyxy">xywhn2xyxy</a></code></li>
<li><code><a title="pancake.utils.general.xyxy2xywh" href="#pancake.utils.general.xyxy2xywh">xyxy2xywh</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>